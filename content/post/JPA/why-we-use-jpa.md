---
categories: diary
date: "2022-12-17T00:00:00Z"
tags: ['JPA']
title: '# 우리는 왜 JPA 를 사용하는가 ?'
draft: true
---

JPA는 Java 진영에서 사용하는 ORM 프레임워크 중 하나입니다. 근래에는 많은 기업에서 JPA를 적극적으로 도입하고 있고, 실제로 JPA를 사용해보면 코드 생산성 측면에서 압도적인 편의성을 제공함을 실감할 수 있습니다. Spring Data JPA를 사용하면, 메소드의 이름을 적는것만으로도 SQL문을 생성하고, 사용할 수 있죠. 하지만, JPA에 대한 이해 없이 단순하게 사용하면 쿼리 성능이 낮아집니다. 대표적으로 `N+1` 문제가 있죠. 이러한 trade-off 에도 불구하고, 우리는 왜 JPA를 사용할까요 ? 오늘은 그 이유에 대한 개인적인 고찰을 서술해보고자 합니다.

### 패러다임의 차이 ?
누군가를 붙잡고 "JPA 를 왜 쓰나요?" 라고 물어보면, 아마 "객체지향과 RDB의 패러다임이 달라서" 라는 답변을 으레 들을 수 있습니다. JPA 하면 이제 대명사로 자리잡은 김영한님의 [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/90439472)에서는 다음과 같이 설명합니다.

> 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다.  
> 그리고 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다.  
> 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다.  
> 이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라 한다.  
> 자바 ORM 표준 JPA 프로그래밍(김영한 저), p.40

즉, 객체지향이라는 패러다임이 해결하고자하는 목적은 객체가 다루는 데이터와 행위를 책임이라는 기준으로 분리함으로써 사람이 이해할 수 있는 코드의 복잡성을 낮추는데 주안점이 있고, 관계형 데이터베이스는 데이터를 최대한 효율적으로 저장하여 빠르게 접근하는데 그 목적성이 있습니다. 

[하이버네이트 공식문서](https://hibernate.org/orm/what-is-an-orm/)에서는 ORM 에 대해 다음과 같이 정의합니다.

> [The Object-Relational Impedance Mismatch](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch)
> 'Object-Relational Impedance Mismatch' (sometimes called the 'paradigm mismatch') is just a fancy way of saying that object models and relational models do not work very well together. RDBMSs represent data in a tabular format (a spreadsheet is a good visualization for those not familiar with RDBMSs), whereas object-oriented languages, such as Java, represent it as an interconnected graph of objects. Loading and storing graphs of objects using a tabular relational database exposes us to 5 mismatch problems…​

> 패러다임 불일치라고 불리기도 하는 'Object-Relational Impedance Mismatch' 는 객체 모델과 관계형 모델이 서로 잘 동작하지 않는다는 것을 그저 멋있게 말하는 것입니다. RDBMS는 테이블의 형태로 데이터를 표현합니다.(RDBMS가 친숙하지 않은 사람들에게는 스프레드시트가 좋은 시각적 형태입니다.) 반면, 자바와 같은 객체지향 언어는 상호 연결된 객체 그래프로 데이터를 표현합니다. 테이블의 관계형 데이터베이스를 사용해 객체의 그래프를 읽거나 저장하는 것은 5가지의 문제를 노출합니다...

### ???
클라이언트-서버 모델에서는 클라이언트가 서버에게 필요한 데이터를 요청하고, 서버는 클라이언트에게 요청한 데이터를 응답합니다. 순수한 CRUD 작업이라면, 클라이언트가 직접 데이터베이스에 접근해서 요청을 보내도 무방하지만, 규모가 커짐에 따라 클라이언트의 복잡성, 보안, 프로시저의 가독성과 같은 다양한 단점들이 부각됩니다. 이에 따라, 사람이 중간에서 쉽게 제어할 수 있는 미들웨어를 배치하고, 비즈니스 로직을 해당 미들웨어에서 관리하는 아키텍쳐가 주목받게 되었습니다.

프로그래밍 언어로 개발한 어플리케이션 프로그램은 데이터와 행위를 갖습니다. RDBMS 는 데이터만을 갖습니다. 하지만 어플리케이션 프로그램은 메모리에 상주하기 때문에, 해당 데이터는 휘발될 수 있으므로 RDBMS 에 모든 데이터를 저장하고, 필요할 때마다 꺼내서 사용하는 방식을 취하게 됩니다. 하지만 우리가 **"필요에 의해"** RDBMS 에서 꺼낸 데이터와, 객체지향에서 바라보는 데이터의 형태가 달라지게 됩니다. 

### ???

프로그래밍을 하다보면 자주 듣는 '대원칙' 중 하나는 "중복을 없애야 한다"는 말입니다. 클린 아키텍처에서는 중복의 종류에 대해 이야기합니다. 

> 하지만 중복에도 여러 종류가 있다. 그중 하나는 진짜 중복이다. 이 경우 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다. 또 다른 중복은 거짓된 또는 우발적인 중복이다. 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다. 
<!-- > 클린 아키텍처(로버트 C 마틴 저), p.??? -->

여기서 우리는 중복을 왜 가급적이면 피해야하는지 알 수 있습니다. 중복이 존재하는 상황에서, 변경점이 발생했을 때 동일한 변경을 모든 복사본(즉, 중복된 코드)에 적용해야 하기 때문입니다. 우리는 사람이기 때문에 모든 중복에 변경을 반드시 적용할 수 있을거라는 보장이 없습니다. 혼자 개발한 수백~수천 라인에도 중복이 어디에 존재하는지 찾기 힘든데, 수십명이 달라붙어 개발한 수십만 라인의 코드에서 중복을 찾기란 현실적으로 불가능합니다.

객체지향이 사람이 인지할 수 있는 코드의 복잡성을 낮추어 생산성을 증대시키는 것이 목적임을 고려한다면, 우리가 작성한 어플리케이션 프로그램에 로직을 작성하는것이 더 합리적인 판단일 것입니다. 그런데 '메소드'라는 이름으로 불리우는 행위 집합의 수행 결과물을 데이터베이스에 반영해야 합니다. 이 '데이터베이스에 반영하는 방법'이 바로 SQL 문입니다.

여기서 중복이 발생한다.

## 정규화 vs 객체 ?



---


개인적인 생각으로는

프로그래밍에서 대원칙은 중복을 없애는 것.
중복을 왜 없애야할까 ? 하나만 고치고 다른쪽에서 안고치는 실수가 잦기 때문.

유지보수성을 감안하면 자바코드에 로직을 작성하는게 좋음.
근데 그 결과를 db에 반영하기가 까다로움.

게다가, 자바에서 필드가 늘어난게 sql에서 핸들링한다던지, 이런 부분이 까다로움.

그래서 이 두개를 맞추는게 orm

다만, 그만큼 기술적인 난이도가 높음.

무게중심을 자바쪽으로 끌고온 만큼, 데이터베이스의 손해를 볼수밖에없음.

하이버네이트에서는 이걸 개선하려고 다양한 기능을 제공해줌.

이걸 잘 알고 쓰면 두마리 토끼를 다 잡을 수 있음.


https://hibernate.org/orm/what-is-an-orm/
논쟁들..
https://okky.kr/articles/286812
