<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>도메인과 레이어드 아키텍처 - cjlee38</title>
<meta name=theme-color><meta name=description content="약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.
정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다."><meta name=author content="cjlee38"><link rel="preload stylesheet" as=style href=https://cjlee38.github.io/blog/main.min.css><link rel=preload as=image href=https://cjlee38.github.io/blog/theme.png><script defer src=https://cjlee38.github.io/blog/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://cjlee38.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://cjlee38.github.io/blog/apple-touch-icon.png><meta name=generator content="Hugo 0.127.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta itemprop=name content="도메인과 레이어드 아키텍처"><meta itemprop=description content="약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.
정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다."><meta itemprop=datePublished content="2022-10-25T00:00:00+00:00"><meta itemprop=dateModified content="2022-10-25T00:00:00+00:00"><meta itemprop=wordCount content="1354"><meta itemprop=keywords content="Layered-Architecture"><meta property="og:url" content="https://cjlee38.github.io/blog/post/domain-layered-architecture/"><meta property="og:site_name" content="cjlee38"><meta property="og:title" content="도메인과 레이어드 아키텍처"><meta property="og:description" content="약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.
정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-25T00:00:00+00:00"><meta property="article:tag" content="Layered-Architecture"><meta name=twitter:card content="summary"><meta name=twitter:title content="도메인과 레이어드 아키텍처"><meta name=twitter:description content="약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 Spark Java 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.
정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다."><link rel=canonical href=https://cjlee38.github.io/blog/post/domain-layered-architecture/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://cjlee38.github.io/blog/>cjlee38</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/blog/categories/>categories</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/blog/tags/>tags</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">도메인과 레이어드 아키텍처</h1><div class="text-sm antialiased opacity-60"><time>Oct 25, 2022</time></div></header><section><p>약 8개월 간의 우아한테크코스를 진행하면서 배우고, 또 고민한 것 중 하나는, 소프트웨어의 책임을 어떻게 분리할 것인가에 관한 것이었다. 레벨 1 당시에는 콘솔 프로그래밍으로 도메인을 어떻게 구성할 것인지에 대해 다루었다. 레벨 2 로 넘어와서는 <a href=https://sparkjava.com/>Spark Java</a> 와 Spring을 추가하면서 도메인을 안정적으로 만드는 것이 왜 중요한지에 대해 학습하였고, 레벨 3에 이르러서는 JPA를 사용하면서 데이터베이스를 연결했을 때 겪는 문제점들을 ORM이 어떻게 풀어나가는지 배웠다.</p><p>정리하자면, 어떻게 하면 도메인을 잘 만들 수 있는지, 그리고 이 도메인을 외부 환경으로부터 어떻게 격리하여 흔들리지 않게 만들 수 있는지를 학습하는 과정이었다. 그런데 잠깐, 여기서 도메인이란 무엇일까 ?</p><h2 id=도메인에-대한-정의>도메인에 대한 정의</h2><p>도메인은 결국, &ldquo;내가 문제를 해결하고자 하는 영역"으로 정의할 수 있다. 가령 쇼핑몰 사이트를 만든다고 하면, 쇼핑의 대상이 되는 상품과 이에 따른 주문/결제 시스템이 바로 도메인이다. 이 과정에서 사용되는 <code>jackson</code>과 같은 라이브러리들은 나의 관심사가 아니다. 한편, <code>jackson</code>과 같은 소프트웨어를 만든다고 하면, 이러한 직렬화/역직렬화 과정을 처리하는 과정이 도메인이다.</p><blockquote><p>나는 도메인에 도움을 주는 이런 부가 기술들을 <strong>&lsquo;코드 레벨&rsquo;</strong>, 혹은 <strong>&lsquo;코드 관점&rsquo;</strong> 이라고 표현하는데, 정확한 용어가 있는지는 모르겠다.</p></blockquote><p>그렇다면 왜 도메인이 중요할까 ? 우리가 소프트웨어로 문제를 해결하고자 하는 이유는, 만들어낸 소프트웨어가 <strong>가치를 창출</strong>해내기 때문이다. 주어진 문제를 코드로 해결하기 위해선 여러 방법이 존재한다. main 메소드에 수천라인의 코드를 박아넣을 수도 있고, 단 하나의 데이터베이스 쿼리로 해결할 수도 있다. 단 한번만 만들어지고, 절대 변하지 않을 예정이라면 이렇게 해도 문제가 되지 않을것이다. 문제가 되는 경우는, 나를 포함한 누군가가 이 코드를 수정해야할 일이 생겼을 때 발생한다.</p><p>그리고 이러한 코드를 특정한 곳에 모아두지 않으면, 새로운 요구사항을 반영하고, 버그를 수정할 때 여러 곳을 살펴봐야 한다. 사람의 인지능력은 한계가 있기 때문에 수백개가 넘어가는 클래스와 수천, 수만 라인의 코드를 모두 파악하는 것은 어렵다. <strong>&lsquo;관심사의 분리&rsquo;</strong> 라는 개념이 바로 여기서 등장한다.</p><blockquote><p>이에 비해 단기 기억은 보관돼 있는 지식에 직접 접근할 수 있지만 정보를 보관할 수 있는 속도와 공간적인 측면 모두에서 제약을 받는다. 공간적인 제약은 조지 밀러(George Miller)의 매직넘버 7(7 ± 2 규칙)로 널리 알려져 있다. 조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 5개에서 많아 봐야 9개 정도를 넘지 못한다고 한다.<br>또한 허버트 사이먼(Herbert A. Simon)에 따르면 사람이 새로운 정보를 받아들이는 데 5초 정도의 시간이 소요된다고 한다. 컴퓨터 프로그램을 작성할 때는 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만 사람의 경우에는 트레이드오프의 여지가 전혀 없다. 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용하는 것이다.<br>(출처 : 오브젝트, 조영호 저)</p></blockquote><p>그리고 이러한 비즈니스 규칙을 모아놓는 곳, 소프트웨어의 본질과 정수를 담아둔 곳이 바로 도메인이다. 그렇기에 우리는 <strong>도메인을 보호</strong>하고, <strong>변경의 여지가 높은 외부 환경으로부터 격리하는 것</strong>을 두 번째 우선순위로 잡아야한다. (<em>당연히 첫 번째는, 올바르게 동작하는 것이다.</em>)</p><p><img src=2022-10-25-22-33-10.png alt></p><h2 id=레이어드-아키텍처>레이어드 아키텍처</h2><p>도메인이 가장 중요하고, 우리가 보호해야할 대상이란 점은 알았다. 이번에는 practical 한 이야기를 해보자. 바로 이 글의 타이틀에도 작성되어 있는 레이어드 아키텍쳐이다. 레이어드 아키텍쳐는 <code>Spring MVC</code> 에서 주로(그리고 거의 대부분) 채택되는 아키텍쳐이기도 하다. 우리에게는 <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 과 같은 친숙한 어노테이션으로도 알려져있다.</p><p><img src=2022-10-25-22-39-11.png alt></p><blockquote><p>참고로 위 세 개의 어노테이션을 들어가보면 모두 <code>DDD</code> 에 어느정도 근간을 두고 있음을 알 수 있다.</p></blockquote><p>구글에 layered architecture 를 검색해보면 여러 글이 나오지만, 결국 논하고자 하는 바는 &ldquo;의존성은 한 쪽으로만 이루어져야 한다"는 것이다. 가령 컨트롤러에서 레포지토리를 곧바로 의존한다고 하더라도 순수한 레이어드 아키텍쳐 관점에서는 문제가 되지 않는다. 컨트롤러는 레포지토리보다 상위에 위치한다.</p><figure><img src=/blog/post/domain-layered-architecture/2022-10-25-23-14-24.png width=300px></figure><p>이제 각 세 개의 레이어가 중점적으로 다뤄야 할 관심사에 대해서 알아보겠다.</p><blockquote><p>참고로 본 글에서는 <code>presentation == controller</code>, <code>application == service</code> 로 취급한다.</p></blockquote><h3 id=controller>Controller</h3><p>컨트롤러는 외부 API 요청을 받아내는 역할을 한다. 개발자 입장에서는 외부 통신을 받아내는 가장 첫 번째 관문이기도 하다.(물론 interceptor나 filter 도 있긴 한다만, 여기선 신경쓰지 않겠다.) 컨트롤러 level 에서 주로 처리해야할 사항은 주로 &lsquo;코드 관점&rsquo;에 집중되어 있다. 내가 원하는 올바른 값이 들어 왔는지? 올바른 사용자가 요청을 보낸 것인지? 내가 원하는 양식(e.g. json)대로 값을 요청했는지? 등을 확인하고, 이에 걸맞게 코드의 객체로 역직렬화하는 과정이 주요 관심사이다.</p><p>때로는 컨트롤러의 코드가 너무 짧아서 아무것도 하는 일이 없어보이기도 한다. 그저 서비스로의 메소드를 호출하고, return 받은 결과를 곧바로 상태코드와 함께 넘겨주는 작업밖에 하지 않는다. 하지만 &lsquo;코드 관점&rsquo;의 작업은 &lsquo;라이브러리&rsquo;, 혹은 &lsquo;프레임워크&rsquo;가 개입하기 아주 좋은 환경이기도 한다. 모든 개발자가 json 오브젝트를 역직렬화하고, 모든 개발자가 내가 정의한 URI 에 요청이 들어오기를 바란다. 따라서 &ldquo;하는 일이 없는 것 처럼 보이는 것&rdquo; 일 뿐, 실제로는 여러 작업이 발생하고 있다.</p><p><img src=2022-10-25-23-20-31.png alt></p><h3 id=service>Service</h3><p>서비스는 도메인의 시작점 역할을 한다. 서비스 상위에 위치하는 컨트롤러로부터 특정한 요청을 받고, 하위에 위치하는 도메인을 모아서, 내가 원하는 비즈니스를 처리한다.</p><p>이 글을 읽는 많은 분들이 객체지향의 5가지 원칙인 <code>SOLID</code>에 대해 알고 계실 것이라 생각한다. 그리고 이러한 <code>SOLID</code> 원칙을 지키기 위한 방법 중 하나로 의존성 주입(Dependency Injection) 이 있다. 의존성을 주입받는다는 것은, A 라는 클래스가 B 라는 클래스를 사용할 때, 어떠한 구현체가 들어오는지에 대해선 관심이 없고, 그저 (A 입장에서)&lsquo;주어진 객체가 내가 원하는 것을 알아서 잘 수행해주기를 바라는 태도&rsquo; 로 이해할 수 있다. 비슷한 주제로 &lsquo;메소드를 호출하는 것이 아니라 메세지를 전달하는 것&rsquo; 이라는 내용도 있는데, 여기서는 생략하겠다.</p><p>아무튼 간에, 이렇듯 의존성을 주입받게 되면, 생성의 책임은 &lsquo;나를 만드는 곳&rsquo;으로 위임하게 된다. 아래 그림과 같이 의존성의 방향성이 있다고 가정해보겠다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>	B b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>A</span>(B b) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> {
</span></span><span style=display:flex><span>	C c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>B</span>(C c) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>여기서 <code>A</code> 클래스는 <code>B</code> 클래스를, <code>B</code> 클래스는 <code>C</code> 클래스를 의존하고 있다. 위와 같은 구조가 주어졌을 때, <code>A</code> 클래스의 인스턴스를 생성하고, 사용하려면 아래와 같이 작성해야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>A a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> A(<span style=color:#66d9ef>new</span> B(<span style=color:#66d9ef>new</span> C()));
</span></span></code></pre></div><p>그런데 생각해보면, 이렇게 생성하는 것이 괜찮을까 ? 결국 이 <code>A</code> 객체를 사용하는 곳도 의존성을 주입받아야 하는 것은 아닐까? 이를 바꿔 말하면, 이렇게 <strong>객체의 생성을 미루고 미루다 보면</strong> 최종적으로 도착하는 지점이 어딘가에서 주어져야 한다. 이 지점을 바로 <a href=https://freecontent.manning.com/dependency-injection-in-net-2nd-edition-understanding-the-composition-root/>composition root</a> 라고 부른다. 그리고 우리는 <code>DI 컨테이너</code> 라는 이름으로 <code>Composition Root</code>라는 개념을 구현한다.</p><blockquote><p>참고로, 의존성 주입에는 세 가지 방법이 있는데, 메소드 주입의 경우 composition root 관점으로 바라봤을 때 해결할 수 없기 때문에 논란의 여지가 있다고 말하는 듯 한다.</p></blockquote><blockquote><p>따라서 의존성 주입에는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.</p><ul><li>생성자 주입(constructor injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결</li><li>setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결</li><li>메서드 주입(method injection): 메소드 실행시 인자를 이용한 의존성 해결
메소드 주입을 의존성 주입의 한 종류로 볼 것인가에 대해서는 논란의 여지가 있다. 개인적으로는 외부에서 객체가 필요로 하는 의존성을 해결한다는 측면에서 의존성 주입의 한 종류로 간주한다.<br>(출처 : 오브젝트, 조영호 저)</li></ul></blockquote><p><code>Controller</code> 나 <code>Service</code>와 같은 객체들의 조립은 spring에서 처리해주지만, 우리가 만든 도메인은 조립해주지 않는다.</p><blockquote><p>모든 도메인 객체를 spring bean으로 등록할 수도 있지만, spring 이라는 프레임워크에 대한 의존성이 생긴다. spring bean 으로 등록하는 것이 반드시 나쁜 것만은 아니다. 하지만 spring 프레임워크에 예기치 못한 버그가 발생한다면 어떨까 ? 도메인이 보호해야 할 중요한 대상이라는 점을 감안하면, 일말의 가능성이라도 배제하는 것이 좋다는 입장이 있는 반면, 생산성을 위해 spring에게 맡기는 것도 하나의 방법이 될 수 있다. 결국은 마법의 단어, &lsquo;트레이드오프&rsquo; 다.</p></blockquote><p>그리고 제가 생각하는 <strong>&lsquo;도메인 객체&rsquo;의 composition root 가 바로 &lsquo;서비스&rsquo; 레이어</strong> 이다.</p><h3 id=repository>Repository</h3><p>repository 는 과연 어느 레이어에 속할까요 ? Repository 와 Dao의 차이점에 대해 조금이라도 찾아본 사람은 repository 를 도메인이라고 부른다. 왜 레포지토리는 도메인 레이어에 속할까요? 자꾸 DDD 이야기가 나와서 조금 불편한데, 에릭 에반스의 <em>도메인 주도 설계</em>에서는 레포지토리를 다음과 같이 정의한다.</p><blockquote><p>“repository is a mechanism for encapsulating storage, retrieval, and search behavior, which emulates a collection of objects.”<br>레포지토리는 저장, 검색 및 검색 동작을 캡슐화하는 메커니즘으로, 객체 모음을 모방한다.</p></blockquote><p>즉, 레포지토리는 <strong>&ldquo;어디에 저장되어 있는지는 모르지만 아무튼 내가 원하는 객체가 저장된 곳&rdquo;</strong> 으로 이야기할 수 있다. 말인 즉슨, 도메인 객체의 생명 주기를 관리한다는 것이다. 이는 바꿔 말하면 레포지토리는 도메인 객체를 알고 있어야 함을, 즉 도메인을 의존해야 함을 의미한다. (앞서, 레이어드 아키텍쳐가 의존성을 한 방향으로만 향하게 했다는 점을 감안하면, 그 하위 infrastructure layer에 속할 수 없다.)</p><p>하지만 여기서 한 가지 문제가 발생한다. <strong>&ldquo;어디에 저장되어 있는지는 모르겠는데&rdquo;</strong>, 도대체 어디서부터 데이터를 가져올 수 있을까 ? 우리는 소중하디 소중한 데이터베이스에 객체에 대한 정보가 저장되어 있음을 알고 있다. 그러면 레포지토리가 도메인에 대한 정보를 알고 있으면서 동시에 데이터베이스에 요청을 필요로 하는 모순이 발생한다. 그리고 이 지점에서 객체지향의 특성이 한 가지 발휘된다. 바로 <strong>&lsquo;다형성&rsquo;</strong> 이다.</p><p><img src=2022-10-25-23-29-55.png alt></p><blockquote><p>그림 5.2에서 <code>HL1</code> 모듈은 <code>ML1</code> 모듈의 <code>F()</code> 함수를 호출한다. 소스 코드에서는 <code>HL1</code> 모듈은 인터페이스를 통해 <code>F()</code> 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. <code>HL1</code>은 단순히 <code>ML1</code> 모듈의 <code>F()</code>를 호출할 뿐이다.<br>하지만 <code>ML1</code> 과 <code>I</code> 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.<br>(출처 : 클린 아키텍쳐, 로버트 C 마틴 저)</p></blockquote><p>위 그림에서 <code>HL1</code> 객체를 서비스로, <code>I</code> 인터페이스를 레포지토리 인터페이스로, <code>ML1</code> 객체를 <code>I</code> 인터페이스를 상속하는, 실제 데이터베이스 요청을 진행하는 객체로 바라보면 이야기했던 모순을 해결할 수 있다. 실제 코드를 보더라도, 서비스 객체는 레포지토리 인터페이스를 <code>import</code>할 뿐, 구현체에 대한 정보는 그 어디에서도 찾아볼 수 없다.</p><blockquote><p>이러한 점에서 객체지향은 절차지향과 차이점을 보인다. 절차지향은 실행 제어 흐름에 따라 의존성의 방향이 일방적으로 향할 수 밖에 없다.
<img src=2022-10-25-23-37-14.png alt></p></blockquote></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://cjlee38.github.io/blog/tags/layered-architecture>layered-architecture</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://cjlee38.github.io/blog/post/java-memory-model-explained/><span class=mr-1.5>←</span><span>Java Memory Model explained (feat. Effective Java, Item 78)</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://cjlee38.github.io/blog/post/encoding-with-mysql/><span>문자 인코딩과 MySQL varchar</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://cjlee38.github.io/blog/>cjlee38</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>