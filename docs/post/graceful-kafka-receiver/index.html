<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>reactor-kafka 는 조심하자 | cjlee38</title>
<meta name=keywords content="reactor,kafka,spring"><meta name=description content="지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.
spring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다."><meta name=author content="cjlee38"><link rel=canonical href=https://blog.cjlee.io/post/graceful-kafka-receiver/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cjlee.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cjlee.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cjlee.io/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cjlee.io/apple-touch-icon.png><link rel=mask-icon href=https://blog.cjlee.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.cjlee.io/post/graceful-kafka-receiver/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta property="og:title" content="reactor-kafka 는 조심하자"><meta property="og:description" content="지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.
spring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.cjlee.io/post/graceful-kafka-receiver/"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-21T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="reactor-kafka 는 조심하자"><meta name=twitter:description content="지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.
spring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cjlee.io/post/"},{"@type":"ListItem","position":2,"name":"reactor-kafka 는 조심하자","item":"https://blog.cjlee.io/post/graceful-kafka-receiver/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"reactor-kafka 는 조심하자","name":"reactor-kafka 는 조심하자","description":"지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.\nspring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다.","keywords":["reactor","kafka","spring"],"articleBody":"지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.\nspring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다. kafka message 의 producing/consuming 을 reactive stream chaining 을 이용해 손쉽게 구성할 수 있고, backpressure 와 같은 기능을 활용하여 throughput 을 비교적 손쉽게 다룰 수 있다는 점은 개발자에게 큰 매력으로 다가온다.\n그런데, reactor-kafka 를 사용하면서 문제점을 하나 발견할 수 있었는데, 이는 바로 graceful shutdown 과 관련된 내용이다. kafka 를 다루다 보면 주의깊게 봐야 하는 부분 중 하나가 중복 처리와 관련된 내용인데, 주로 재배포시에 이러한 문제가 자주 발생한다. 그런데, reactor-kafka 를 생각없이 사용하다가는 메세지를 중복으로 소비하거나, 혹은 건너뛰게 되는 불상사가 발생할 수 있다.\n오늘은 이 reactor-kafka 를 사용할 때 graceful shutdown 에 어떤 문제가 있는지 그리고 이를 어떻게 해결하는지에 대해 알아보자.\n카프카 사용 패턴 kafka 를 이용해 메세지를 수신하고 처리하는 방법은 전형적으로 다음과 같은 패턴을 띤다.\n카프카 메세지를 수신한다. 메세지를 처리한다. (DB에 저장하거나, 알림을 발송하는 등의 API 호출) 메세지에 대한 후처리(kafka commit, 혹은 auto commit 을 위한 spring kafka ack 처리 등) 이 때, 메세지에 대한 후처리, 즉 commit 을 하는 방법은 보통 auto commit 을 할지 말지로 나뉘게 된다.\nenable.auto.commit 을 설정하면, auto.commit.interval.ms 에 설정한 값에 따라 주기적으로 백그라운드에서 commit 이 수행된다. 이 때, commit 요청은 polling api 과 함께 수행되며, 현재까지 poll 해온 offset 만큼의 commit 을 수행한다. 따라서, 중간에 리밸런싱이나 재배포와 같은 이유로 데이터 처리와 commit 이 올바르게 수행되지 않으면, 데이터의 유실 혹은 중복이 발생하게 된다.\nreactive stream 이 아니더라도, 대부분의 경우 이러한 문제가 쉽게 발생할 수 있기 때문에 enable.auto.commit 은 false 로 두고, 코드 레벨에서 수기로 동기/비동기 방식의 commit 을 수행하는 것이 일반적이다. 따라서 reactor 를 이용해 데이터를 처리하는 코드를 구현하면 대개 다음과 같다.\nval receiver = KafkaRecever.create(...) receiver.receive() .flatMapSequential { process(it).thenReturn(it) } .delayUntil { it.receiverOffset().commit() } .subscribe() 위 코드를 보면 가장 먼저 데이터를 처리하는 부분을 flatMapSequential 로 처리하고 있는 것을 볼 수 있다. flatMapSequntial 은 flatMap 과 같이 비동기적으로 내부 publisher 를 처리하지만, 그 결과를 다음 operator(여기서는 delayUntil) 로 내려줄 때는 순서를 보장하므로, (즉, interleaving 되지 않는다.) offset 에 대한 commit 순서를 지키기 위해 사용하였다. 물론 상황에 따라, high throughput 이 필요없다거나, 순서를 제어할 필요가 있다거나, 혹은 여러 이유로 인해 concatMap, flatMap 등을 사용할 수도 있다.\n다음으로, delayUntil 은 위에서 언급한대로, 동기적으로 commit 을 수행하면서, 동시에 각 offset commit 간 순서를 지키기 위해 사용하였다. 이 부분 또한 마찬가지로 경우에 따라 다른 operator 로 대체할 수 있다.\n스프링 환경에서는 일반적으로 KafkaReceiver 를 bean 으로 등록한 뒤, 특정 서비스성 컴포넌트에서 주입받아 사용하게 된다.\n그런데, 이 때 갑자기 shutdown 이 들어오면 어떻게 될까? KafkaReceiver 는 비록 bean 으로 등록되었지만, 별도의 shutdown 절차가 존재하지 않으므로, reactive chain 자체가 진행되던 도중 그대로 application process shutdown 으로 마무리 될것이다. 그렇다면, 이미 처리된 데이터가 아직 커밋이 되지 않아 다시 컨슘하는 중복의 문제가 발생할 수 있고, 반대로 커밋 offset 을 적절하게 제어하지 않는다면 데이터 처리가 끝나지 않았지만 죽어버리는 유실의 문제가 발생할 수도 있다. 이러한 문제를 어떻게 해결할 수 있을까 ?\n방법 1. ❌ dispose() 사용하기 가장 먼저 떠올릴 수 있는 방법은, subscribe() 로 튀어나온 Disposable 객체에 dispose() 를 걸어, chain 을 캔슬시키는 방법이 있다.\nval receiver = KafkaRecever.create(...) val disposable = receiver.receive() .flatMapSequential { process(it).thenReturn(it) } .delayUntil { it.receiverOffset().commit() } .subscribe() disposable.dispose() // \u003c- cancel 시그널을 upstream 으로 순차적으로 올려보내준다면, 진행중인 chain 이 적어도 갑작스럽게 무너지는 일은 없을 것 같아 보인다. 하지만, 여전히 문제는 남아있다. 가령, process 가 하나의 작업만 처리하는게 아니라, DB에 데이터도 저장하고, API 요청도 해야하는 등의 I/O 작업이 여러 개가 수반되어 있다면, flatMap 내에서 처리하는 동작의 atomicity 가 보장되지 않는다. 즉, DB 에 데이터는 저장했는데 API 요청을 못했다던가 하는 불상사가 발생한다. 따라서 이 방법은 좋지 못한 것 같다.\ndispose() 를 사용했을 때의 문제점은, cancel 요청이 graceful 하게 처리되지 않는다는 점이다. 다른 방법을 찾아야 한다.\n방법 2. ❌ predicate 이용하기 다음으로 떠올려 볼 수 있는 방법은, takeWhile 혹은 takeUntil 을 이용해 중간에서 멈추는 방식이다.\nval receiver = KafkaRecever.create(...) val shutdown = AtomicBoolean(false) val disposable = receiver.receive() .takeWhile { !shutdown.get() } // \u003c- .flatMapSequential { process(it).thenReturn(it) } .delayUntil { it.receiverOffset().commit() } .subscribe() 위와 같이 shutdown 변수를 하나 둔 뒤에, shutdown 요청이 들어왔을 때 @Predestory 등을 이용해서 해당 변수를 true 로 바꿔주면 되지 않을까 ? takeWhile 은 predicate 를 만족하게 되면, downstream 으로 complete 시그널을 내려주기 때문에, flatMapSequential 과 delayUntil 이 모두 처리되고 나서 종료될 것이다. 따라서, “이제 종료해도 될지?” 를 판단하는 여부를 disposable.isDisposed 로 확인하면 될 것 같다.\n하지만 애석하게도, 이 방법도 올바르게 동작하지는 않는다. 왜냐하면, takeWhile 이 predicate 를 만족했을 때에는 downstream 으로 complete 시그널을 보내지만, 동시에 upstream 으로 cancel 을 보내기 때문이다.\n아래는 takeWhile 의 클래스 구현체인 FluxTakeWhile, 그리고 TakeWhileSubscriber 의 코드 중 일부이다. 주석으로 설명을 달아놓았다.\n@Override public void onNext(T t) { // ... boolean b; try { // 조건에 만족하는지 확인한다. b = predicate.test(t); } catch (Throwable e) { onError(Operators.onOperatorError(s, e, t, actual.currentContext())); return; } // 조건에 만족하지 않으면(shutdown=true) if (!b) { // upstream 으로 cancel 요청을, downstream 으로 onComplete 를 보낸다 s.cancel(); // 이 때 s 는 Subscription 인스턴스 onComplete(); return; } actual.onNext(t); } 여기까지만 보면 괜찮아보이지만, 문제는, upstream 으로 cancel 을 보냈을 때 KafkaReceiver 가 어떤 행위를 하는지이다. KafkaReceiver 는 infinite stream 을 다루기 위해, Sink 를 베이스로 만들어졌는데, 이 Sink 를 종료할 때, 내부에 있는 kafka consumer 를 종료하도록 처리되어있다.. 아래는 DefaultKafkaReceiver 클래스 코드 중 일부이다.\nprivate \u003cT\u003e Flux\u003cT\u003e withHandler(AckMode ackMode, BiFunction\u003cScheduler, ConsumerHandler\u003cK, V\u003e, Flux\u003cT\u003e\u003e function) { return Flux.usingWhen( Mono.fromCallable(() -\u003e { ConsumerHandler\u003cK, V\u003e consumerHandler = new ConsumerHandler\u003c\u003e( receiverOptions, consumerFactory.createConsumer(receiverOptions), // Always use the currently set value e -\u003e isRetriableException.test(e), ackMode ); consumerHandlerRef.set(consumerHandler); return consumerHandler; }), handler -\u003e Flux.using( () -\u003e Schedulers.single(receiverOptions.schedulerSupplier().get()), scheduler -\u003e function.apply(scheduler, handler), Scheduler::dispose ), // 이 handler.close() 를 따라가다 보면, `consumer.close()` 를 호출한다. handler -\u003e handler.close().doFinally(__ -\u003e consumerHandlerRef.compareAndSet(handler, null)) // \u003c- ); } 즉, downstream 이 모두 처리되기도 전에 consumer 가 종료되고, 따라서 downstream 에 있는 delayUntil operator 에서 commit 을 요청했지만, 이미 consumer 는 종료된 상태이므로 올바르게 커밋이 처리되지 않는다.\n참고로, handle operator 또한 downstream 으로 complete 시그널을 방출하면 upstream 으로 cancel 을 보내도록 구현되어있다.\n방법 3. ❓ chain 자체를 halt 시키기 또 다른 방법은, 2번 방법과 비슷하지만 조금 우악스러운 면이 있다. reactor 에는 자주 쓰이지 않아 잘 알려지지 않은 operator 하나가 있는데, 바로 never 이다. 이 never operator 는, 이름 그대로 “아무것도” 하지 않는다.\n즉, onNext, onComplete, onError 등 아무런 signal 을 downstream 으로 내려주지 않는다. 이를 이용해 다음과 같이 kafka receiver 를 중지시킬수 있다.\nval receiver = KafkaRecever.create(...) val shutdown = AtomicBoolean(false) val disposable = receiver.receive() .delayUntil { if (shutdown.get()) { Mono.never() } else { Mono.empty() } } .flatMapSequential { process(it).thenReturn(it) } .delayUntil { it.receiverOffset().commit() } .subscribe() 이렇게 중지시켜버리면, downstream 의 flatMap 과 delayUntil 은 정상적으로 처리될 것이다. 다만, disposable.isDisposed 로 모두 처리되었는지 확인할 수는 없다. 약간 아쉬운 부분이 있다.\n방법 4. ✅ 새로운 Sink 구축하기 우리는 위 해결 방법들을 살펴보면서, 여러 힌트를 얻었다. 우리가 원하는 것은 complete 시그널을 downstream 으로 내려줘서, 모든 record 에 대한 처리가 자연스럽게 끝나기를 원한다. 그런데 reactive chain 의 중간에서 complete 시그널을 내려주는 방법은 필연적으로 upstream 으로의 cancel 을 수반하기 때문에 문제가 된다. 또한, never operator 를 이용해서 reactive chain 을 중단시킬수도 있다는 것을 알게 되었다.\n그러면 만약, 우리가 새로운 sink 를 만들게 되면, complete 시그널에 대한 처리도 자유롭게 처리할 수 있고, 이 sink 가 모두 처리가 끝났을 때 kafka receiver 에 대한 cancel 처리를 한다면 모두 해결되지 않을까? 다음 코드가 그 고민의 결과물이다.\nval receiver = KafkaRecever.create(...) val shutdown = AtomicBoolean(false) val sink = Sinks.many().unicast().onBackpressureBuffer","wordCount":"1474","inLanguage":"en","datePublished":"2025-01-21T00:00:00Z","dateModified":"2025-01-21T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cjlee.io/post/graceful-kafka-receiver/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://blog.cjlee.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cjlee.io/ accesskey=h title="Home (Alt + H)"><img src=https://blog.cjlee.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.cjlee.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://blog.cjlee.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cjlee.io/>Home</a>&nbsp;»&nbsp;<a href=https://blog.cjlee.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">reactor-kafka 는 조심하자</h1><div class=post-meta><span title='2025-01-21 00:00:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/graceful-kafka-receiver/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%b9%b4%ed%94%84%ec%b9%b4-%ec%82%ac%ec%9a%a9-%ed%8c%a8%ed%84%b4 aria-label="카프카 사용 패턴">카프카 사용 패턴</a></li><li><a href=#%eb%b0%a9%eb%b2%95-1--dispose-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0 aria-label="방법 1. ❌ dispose() 사용하기">방법 1. ❌ dispose() 사용하기</a></li><li><a href=#%eb%b0%a9%eb%b2%95-2-predicate-%ec%9d%b4%ec%9a%a9%ed%95%98%ea%b8%b0 aria-label="방법 2. ❌ predicate 이용하기">방법 2. ❌ predicate 이용하기</a></li><li><a href=#%eb%b0%a9%eb%b2%95-3-chain-%ec%9e%90%ec%b2%b4%eb%a5%bc-halt-%ec%8b%9c%ed%82%a4%ea%b8%b0 aria-label="방법 3. ❓ chain 자체를 halt 시키기">방법 3. ❓ chain 자체를 halt 시키기</a></li><li><a href=#%eb%b0%a9%eb%b2%95-4-%ec%83%88%eb%a1%9c%ec%9a%b4-sink-%ea%b5%ac%ec%b6%95%ed%95%98%ea%b8%b0 aria-label="방법 4. ✅ 새로운 Sink 구축하기">방법 4. ✅ 새로운 Sink 구축하기</a></li><li><a href=#%eb%a7%88%eb%ac%b4%eb%a6%ac aria-label=마무리>마무리</a></li></ul></div></details></div><div class=post-content><p>지난 약 1년 조금 넘는 기간 동안, 미들웨어 기능을 담당하는 알림 플랫폼을 구축하는 업무를 진행했다. 알림 플랫폼 구축 시 요구사항 중 하나는 알림 발송을 수신하는 서버 역할의 서비스에는 TPS 에 대한 제한이 있지만, 알림 발송을 요청하는 클라이언트의 서비스는 TPS 에 대한 제어 없이 무작위로 발송할 수 있어야 한다는 것이기 때문에, 적절한 제어와 high throughput 을 보장하기 위해 spring webflux 와 kafka 를 사용했다.</p><p>spring webflux 환경에서, kafka 를 사용할 일이 생기면 일반적으로 reactor-kafka 를 채택하기 마련이다. kafka message 의 producing/consuming 을 reactive stream chaining 을 이용해 손쉽게 구성할 수 있고, backpressure 와 같은 기능을 활용하여 throughput 을 비교적 손쉽게 다룰 수 있다는 점은 개발자에게 큰 매력으로 다가온다.</p><p>그런데, reactor-kafka 를 사용하면서 문제점을 하나 발견할 수 있었는데, 이는 바로 graceful shutdown 과 관련된 내용이다. kafka 를 다루다 보면 주의깊게 봐야 하는 부분 중 하나가 중복 처리와 관련된 내용인데, 주로 재배포시에 이러한 문제가 자주 발생한다. 그런데, reactor-kafka 를 생각없이 사용하다가는 메세지를 중복으로 소비하거나, 혹은 건너뛰게 되는 불상사가 발생할 수 있다.</p><p>오늘은 이 reactor-kafka 를 사용할 때 graceful shutdown 에 어떤 문제가 있는지 그리고 이를 어떻게 해결하는지에 대해 알아보자.</p><h3 id=카프카-사용-패턴>카프카 사용 패턴<a hidden class=anchor aria-hidden=true href=#카프카-사용-패턴>#</a></h3><p>kafka 를 이용해 메세지를 수신하고 처리하는 방법은 전형적으로 다음과 같은 패턴을 띤다.</p><ol><li>카프카 메세지를 수신한다.</li><li>메세지를 처리한다. (DB에 저장하거나, 알림을 발송하는 등의 API 호출)</li><li>메세지에 대한 후처리(kafka commit, 혹은 auto commit 을 위한 spring kafka ack 처리 등)</li></ol><p>이 때, 메세지에 대한 후처리, 즉 commit 을 하는 방법은 보통 auto commit 을 할지 말지로 나뉘게 된다.</p><p><code>enable.auto.commit</code> 을 설정하면, <code>auto.commit.interval.ms</code> 에 설정한 값에 따라 주기적으로 백그라운드에서 commit 이 수행된다. 이 때, commit 요청은 polling api 과 함께 수행되며, 현재까지 poll 해온 offset 만큼의 commit 을 수행한다. 따라서, 중간에 리밸런싱이나 재배포와 같은 이유로 데이터 처리와 commit 이 올바르게 수행되지 않으면, 데이터의 유실 혹은 중복이 발생하게 된다.</p><p>reactive stream 이 아니더라도, 대부분의 경우 이러한 문제가 쉽게 발생할 수 있기 때문에 <code>enable.auto.commit</code> 은 false 로 두고, 코드 레벨에서 수기로 동기/비동기 방식의 commit 을 수행하는 것이 일반적이다. 따라서 reactor 를 이용해 데이터를 처리하는 코드를 구현하면 대개 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> receiver = <span style=color:#a6e22e>KafkaRecever</span>.create(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>receiver</span>.receive()
</span></span><span style=display:flex><span>	.flatMapSequential { process(<span style=color:#66d9ef>it</span>).thenReturn(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>	.delayUntil { <span style=color:#66d9ef>it</span>.receiverOffset().commit() }
</span></span><span style=display:flex><span>	.subscribe()
</span></span></code></pre></div><p>위 코드를 보면 가장 먼저 데이터를 처리하는 부분을 <code>flatMapSequential</code> 로 처리하고 있는 것을 볼 수 있다. <code>flatMapSequntial</code> 은 <code>flatMap</code> 과 같이 비동기적으로 내부 publisher 를 처리하지만, 그 결과를 다음 operator(여기서는 <code>delayUntil</code>) 로 내려줄 때는 순서를 보장하므로, (즉, interleaving 되지 않는다.) offset 에 대한 commit 순서를 지키기 위해 사용하였다. 물론 상황에 따라, high throughput 이 필요없다거나, 순서를 제어할 필요가 있다거나, 혹은 여러 이유로 인해 <code>concatMap</code>, <code>flatMap</code> 등을 사용할 수도 있다.</p><p>다음으로, <code>delayUntil</code> 은 위에서 언급한대로, 동기적으로 commit 을 수행하면서, 동시에 각 offset commit 간 순서를 지키기 위해 사용하였다. 이 부분 또한 마찬가지로 경우에 따라 다른 operator 로 대체할 수 있다.</p><p>스프링 환경에서는 일반적으로 <code>KafkaReceiver</code> 를 bean 으로 등록한 뒤, 특정 서비스성 컴포넌트에서 주입받아 사용하게 된다.</p><p>그런데, 이 때 갑자기 shutdown 이 들어오면 어떻게 될까? <code>KafkaReceiver</code> 는 비록 bean 으로 등록되었지만, 별도의 shutdown 절차가 존재하지 않으므로, reactive chain 자체가 진행되던 도중 그대로 application process shutdown 으로 마무리 될것이다. 그렇다면, 이미 처리된 데이터가 아직 커밋이 되지 않아 다시 컨슘하는 중복의 문제가 발생할 수 있고, 반대로 커밋 offset 을 적절하게 제어하지 않는다면 데이터 처리가 끝나지 않았지만 죽어버리는 유실의 문제가 발생할 수도 있다. 이러한 문제를 어떻게 해결할 수 있을까 ?</p><h3 id=방법-1--dispose-사용하기>방법 1. ❌ dispose() 사용하기<a hidden class=anchor aria-hidden=true href=#방법-1--dispose-사용하기>#</a></h3><p>가장 먼저 떠올릴 수 있는 방법은, <code>subscribe()</code> 로 튀어나온 <code>Disposable</code> 객체에 <code>dispose()</code> 를 걸어, chain 을 캔슬시키는 방법이 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> receiver = <span style=color:#a6e22e>KafkaRecever</span>.create(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> disposable = <span style=color:#66d9ef>receiver</span>.receive()
</span></span><span style=display:flex><span>	.flatMapSequential { process(<span style=color:#66d9ef>it</span>).thenReturn(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>	.delayUntil { <span style=color:#66d9ef>it</span>.receiverOffset().commit() }
</span></span><span style=display:flex><span>	.subscribe()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>disposable.dispose() <span style=color:#75715e>// &lt;-
</span></span></span></code></pre></div><p>cancel 시그널을 upstream 으로 순차적으로 올려보내준다면, 진행중인 chain 이 적어도 갑작스럽게 무너지는 일은 없을 것 같아 보인다. 하지만, 여전히 문제는 남아있다. 가령, process 가 하나의 작업만 처리하는게 아니라, DB에 데이터도 저장하고, API 요청도 해야하는 등의 I/O 작업이 여러 개가 수반되어 있다면, <code>flatMap</code> 내에서 처리하는 동작의 atomicity 가 보장되지 않는다. 즉, DB 에 데이터는 저장했는데 API 요청을 못했다던가 하는 불상사가 발생한다. 따라서 이 방법은 좋지 못한 것 같다.</p><p><code>dispose()</code> 를 사용했을 때의 문제점은, cancel 요청이 graceful 하게 처리되지 않는다는 점이다. 다른 방법을 찾아야 한다.</p><h3 id=방법-2-predicate-이용하기>방법 2. ❌ predicate 이용하기<a hidden class=anchor aria-hidden=true href=#방법-2-predicate-이용하기>#</a></h3><p>다음으로 떠올려 볼 수 있는 방법은, <code>takeWhile</code> 혹은 <code>takeUntil</code> 을 이용해 중간에서 멈추는 방식이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> receiver = <span style=color:#a6e22e>KafkaRecever</span>.create(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> shutdown = AtomicBoolean(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> disposable = <span style=color:#66d9ef>receiver</span>.receive()
</span></span><span style=display:flex><span>	.takeWhile { !shutdown.<span style=color:#66d9ef>get</span>() } <span style=color:#75715e>// &lt;-
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	.flatMapSequential { process(<span style=color:#66d9ef>it</span>).thenReturn(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>	.delayUntil { <span style=color:#66d9ef>it</span>.receiverOffset().commit() }
</span></span><span style=display:flex><span>	.subscribe()
</span></span></code></pre></div><p>위와 같이 <code>shutdown</code> 변수를 하나 둔 뒤에, shutdown 요청이 들어왔을 때 <code>@Predestory</code> 등을 이용해서 해당 변수를 true 로 바꿔주면 되지 않을까 ? <code>takeWhile</code> 은 predicate 를 만족하게 되면, downstream 으로 <code>complete</code> 시그널을 내려주기 때문에, <code>flatMapSequential</code> 과 <code>delayUntil</code> 이 모두 처리되고 나서 종료될 것이다. 따라서, “이제 종료해도 될지?” 를 판단하는 여부를 <code>disposable.isDisposed</code> 로 확인하면 될 것 같다.</p><p>하지만 애석하게도, 이 방법도 올바르게 동작하지는 않는다. 왜냐하면, <code>takeWhile</code> 이 predicate 를 만족했을 때에는 downstream 으로 complete 시그널을 보내지만, 동시에 upstream 으로 cancel 을 보내기 때문이다.</p><p>아래는 takeWhile 의 클래스 구현체인 <code>FluxTakeWhile</code>, 그리고 <code>TakeWhileSubscriber</code> 의 코드 중 일부이다. 주석으로 설명을 달아놓았다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span>(T t) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>boolean</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 조건에 만족하는지 확인한다.</span>
</span></span><span style=display:flex><span>		b <span style=color:#f92672>=</span> predicate.<span style=color:#a6e22e>test</span>(t);
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>catch</span> (Throwable e) {
</span></span><span style=display:flex><span>		onError(Operators.<span style=color:#a6e22e>onOperatorError</span>(s, e, t, actual.<span style=color:#a6e22e>currentContext</span>()));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 조건에 만족하지 않으면(shutdown=true) </span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>b) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// upstream 으로 cancel 요청을, downstream 으로 onComplete 를 보낸다</span>
</span></span><span style=display:flex><span>		s.<span style=color:#a6e22e>cancel</span>(); <span style=color:#75715e>// 이 때 s 는 Subscription 인스턴스</span>
</span></span><span style=display:flex><span>		onComplete();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	actual.<span style=color:#a6e22e>onNext</span>(t);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>여기까지만 보면 괜찮아보이지만, 문제는, upstream 으로 cancel 을 보냈을 때 KafkaReceiver 가 어떤 행위를 하는지이다. <code>KafkaReceiver</code> 는 infinite stream 을 다루기 위해, <code>Sink</code> 를 베이스로 만들어졌는데, 이 <code>Sink</code> 를 종료할 때, <strong>내부에 있는 kafka consumer 를 종료하도록 처리되어있다.</strong>. 아래는 <code>DefaultKafkaReceiver</code> 클래스 코드 중 일부이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Flux<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>withHandler</span>(AckMode ackMode, BiFunction<span style=color:#f92672>&lt;</span>Scheduler, ConsumerHandler<span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span>, Flux<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> function) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> Flux.<span style=color:#a6e22e>usingWhen</span>(
</span></span><span style=display:flex><span>		Mono.<span style=color:#a6e22e>fromCallable</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>			ConsumerHandler<span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> consumerHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConsumerHandler<span style=color:#f92672>&lt;&gt;</span>(
</span></span><span style=display:flex><span>				receiverOptions,
</span></span><span style=display:flex><span>				consumerFactory.<span style=color:#a6e22e>createConsumer</span>(receiverOptions),
</span></span><span style=display:flex><span>				<span style=color:#75715e>// Always use the currently set value</span>
</span></span><span style=display:flex><span>				e <span style=color:#f92672>-&gt;</span> isRetriableException.<span style=color:#a6e22e>test</span>(e),
</span></span><span style=display:flex><span>				ackMode
</span></span><span style=display:flex><span>			);
</span></span><span style=display:flex><span>			consumerHandlerRef.<span style=color:#a6e22e>set</span>(consumerHandler);
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> consumerHandler;
</span></span><span style=display:flex><span>		}),
</span></span><span style=display:flex><span>		handler <span style=color:#f92672>-&gt;</span> Flux.<span style=color:#a6e22e>using</span>(
</span></span><span style=display:flex><span>			() <span style=color:#f92672>-&gt;</span> Schedulers.<span style=color:#a6e22e>single</span>(receiverOptions.<span style=color:#a6e22e>schedulerSupplier</span>().<span style=color:#a6e22e>get</span>()),
</span></span><span style=display:flex><span>			scheduler <span style=color:#f92672>-&gt;</span> function.<span style=color:#a6e22e>apply</span>(scheduler, handler),
</span></span><span style=display:flex><span>			Scheduler::dispose
</span></span><span style=display:flex><span>		),
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 이 handler.close() 를 따라가다 보면, `consumer.close()` 를 호출한다.</span>
</span></span><span style=display:flex><span>		handler <span style=color:#f92672>-&gt;</span> handler.<span style=color:#a6e22e>close</span>().<span style=color:#a6e22e>doFinally</span>(__ <span style=color:#f92672>-&gt;</span> consumerHandlerRef.<span style=color:#a6e22e>compareAndSet</span>(handler, <span style=color:#66d9ef>null</span>)) <span style=color:#75715e>// &lt;-</span>
</span></span><span style=display:flex><span>	);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>즉, downstream 이 모두 처리되기도 전에 consumer 가 종료되고, 따라서 downstream 에 있는 <code>delayUntil</code> operator 에서 <code>commit</code> 을 요청했지만, 이미 consumer 는 종료된 상태이므로 올바르게 커밋이 처리되지 않는다.</p><blockquote><p>참고로, <code>handle</code> operator 또한 downstream 으로 complete 시그널을 방출하면 upstream 으로 cancel 을 보내도록 구현되어있다.</p></blockquote><h3 id=방법-3-chain-자체를-halt-시키기>방법 3. ❓ chain 자체를 halt 시키기<a hidden class=anchor aria-hidden=true href=#방법-3-chain-자체를-halt-시키기>#</a></h3><p>또 다른 방법은, 2번 방법과 비슷하지만 조금 우악스러운 면이 있다. reactor 에는 자주 쓰이지 않아 잘 알려지지 않은 operator 하나가 있는데, 바로 <code>never</code> 이다. 이 <code>never</code> operator 는, 이름 그대로 “아무것도” 하지 않는다.</p><p><img loading=lazy src=image.png alt=image.png></p><p>즉, <code>onNext</code>, <code>onComplete</code>, <code>onError</code> 등 아무런 signal 을 downstream 으로 내려주지 않는다. 이를 이용해 다음과 같이 kafka receiver 를 <strong>중지</strong>시킬수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> receiver = <span style=color:#a6e22e>KafkaRecever</span>.create(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> shutdown = AtomicBoolean(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> disposable = <span style=color:#66d9ef>receiver</span>.receive()
</span></span><span style=display:flex><span>	.delayUntil {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (shutdown.<span style=color:#66d9ef>get</span>()) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Mono</span>.never&lt;Unit&gt;()
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Mono</span>.empty&lt;Unit&gt;()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	.flatMapSequential { process(<span style=color:#66d9ef>it</span>).thenReturn(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>	.delayUntil { <span style=color:#66d9ef>it</span>.receiverOffset().commit() }
</span></span><span style=display:flex><span>	.subscribe()
</span></span></code></pre></div><p>이렇게 중지시켜버리면, downstream 의 flatMap 과 delayUntil 은 정상적으로 처리될 것이다. 다만, <code>disposable.isDisposed</code> 로 모두 처리되었는지 확인할 수는 없다. 약간 아쉬운 부분이 있다.</p><h3 id=방법-4-새로운-sink-구축하기>방법 4. ✅ 새로운 Sink 구축하기<a hidden class=anchor aria-hidden=true href=#방법-4-새로운-sink-구축하기>#</a></h3><p>우리는 위 해결 방법들을 살펴보면서, 여러 힌트를 얻었다. 우리가 원하는 것은 complete 시그널을 downstream 으로 내려줘서, 모든 record 에 대한 처리가 자연스럽게 끝나기를 원한다. 그런데 reactive chain 의 중간에서 complete 시그널을 내려주는 방법은 필연적으로 upstream 으로의 cancel 을 수반하기 때문에 문제가 된다. 또한, <code>never</code> operator 를 이용해서 reactive chain 을 중단시킬수도 있다는 것을 알게 되었다.</p><p>그러면 만약, 우리가 새로운 sink 를 만들게 되면, complete 시그널에 대한 처리도 자유롭게 처리할 수 있고, 이 sink 가 모두 처리가 끝났을 때 kafka receiver 에 대한 cancel 처리를 한다면 모두 해결되지 않을까? 다음 코드가 그 고민의 결과물이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> receiver = <span style=color:#a6e22e>KafkaRecever</span>.create(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> shutdown = AtomicBoolean(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> sink = <span style=color:#a6e22e>Sinks</span>.many().unicast().onBackpressureBuffer&lt;ReceiverRecord&lt;String, String&gt;&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> kafkaDisposable = <span style=color:#66d9ef>receiver</span>.receive()
</span></span><span style=display:flex><span>	.delayUntil {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (shutdown.<span style=color:#66d9ef>get</span>()) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Mono</span>.never&lt;Unit&gt;()
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Mono</span>.empty&lt;Unit&gt;()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	.doOnNext { sink.tryEmitNext(<span style=color:#66d9ef>it</span>) } 
</span></span><span style=display:flex><span>	.subscribe()
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> sinkDisposable = sink.asFlux()
</span></span><span style=display:flex><span>	.flatMapSequential { process(<span style=color:#66d9ef>it</span>).thenReturn(<span style=color:#66d9ef>it</span>) }
</span></span><span style=display:flex><span>	.delayUntil { <span style=color:#66d9ef>it</span>.receiverOffset().commit() }
</span></span><span style=display:flex><span>	.doFinally { kafkaDisposable.dispose() }
</span></span><span style=display:flex><span>	.subscribe()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 종료할 때가 되면
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>shutdown.<span style=color:#66d9ef>set</span>(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>sink.tryEmitComplete()
</span></span></code></pre></div><p>코드로 보기에는 조금 헷갈릴 수 있을 것 같아, 그림을 그려보면 다음과 같다.</p><p><img loading=lazy src=image1.png alt=image.png></p><p>이렇게 구현함으로써 다음을 해결할 수 있게 되었다.</p><ol><li>shutdown 이 진행되는 여유 기간(sigterm → sigkill 사이의 term) 동안, consume 한 모든 메세지를 처리할 수 있다.</li><li>모든 메세지가 처리되었는지에 대한 확인은, <code>sinkDisposable.isDisposed</code> 로 확인할 수 있다.</li></ol><p>물론 위 코드는 개략적인 모습일 뿐, 사실 저 코드만으로 복사해서 사용하기에는 부족한 부분이 많다.. 스프링의 shutdown hook 에 integration 도 필요하고, 데이터의 emit 처리가 너무 빠르기 때문에 적절한 back pressure 전략도 필요하다. 하지만 어찌됐든 graceful shutdown 동작에는 무리가 없어 보인다.</p><h3 id=마무리>마무리<a hidden class=anchor aria-hidden=true href=#마무리>#</a></h3><p>사실 가장 좋은 방법은, reactor-kafka 메인테이너가 graceful shutdown 을 할 수 있도록 방법을 제공하는 것이다. 이를 위해 <a href=https://github.com/reactor/reactor-kafka/issues/378>이슈</a>도 남겨보고, <a href=https://github.com/reactor/reactor-kafka/pull/380>PR</a> 도 올려봤지만, reactor-kafka 에 대한 지원이 끊긴건지, 나를 포함한 대부분의 이슈에 대해 activity 가 1년째 끊어진 상태라, 나름대로 우회방법을 구현해보았다.</p><p>그리고, 이 글을 쓰게 된 계기는 “도대체 다른 사람들은 어떻게 하고 있을까?” 가 궁금해서가 너무 컸다. reactor-kafka 라는 프레임워크가 새삼스러운 것도 아니고, graceful shutdown 도 흔하게 고려하는 문제 중 하나이지 않은가 ? outbox pattern 등을 이용하더라도 모두 해결은 되지 않을텐데.. 다른 손쉬운 방법이 있어서 그런걸까? 잘 모르겠다. 잘 아는 분이 있으면 댓글을 남겨주면 고맙겠다.</p><p>아무튼, 이상으로 reactor-kafka 의 graceful shutdown 에 대한 고찰을 마친다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.cjlee.io/tags/reactor/>Reactor</a></li><li><a href=https://blog.cjlee.io/tags/kafka/>Kafka</a></li><li><a href=https://blog.cjlee.io/tags/spring/>Spring</a></li></ul><nav class=paginav><a class=prev href=https://blog.cjlee.io/post/webclient-timeout/><span class=title>« Prev</span><br><span>헷갈리는 WebClient Timeout</span>
</a><a class=next href=https://blog.cjlee.io/post/git-absorb/><span class=title>Next »</span><br><span>Git absorb 소개</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on x" href="https://x.com/intent/tweet/?text=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f&amp;hashtags=reactor%2ckafka%2cspring"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f&amp;title=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90&amp;summary=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90&amp;source=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f&title=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on whatsapp" href="https://api.whatsapp.com/send?text=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90%20-%20https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on telegram" href="https://telegram.me/share/url?text=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share reactor-kafka 는 조심하자 on ycombinator" href="https://news.ycombinator.com/submitlink?t=reactor-kafka%20%eb%8a%94%20%ec%a1%b0%ec%8b%ac%ed%95%98%ec%9e%90&u=https%3a%2f%2fblog.cjlee.io%2fpost%2fgraceful-kafka-receiver%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=cjlee38/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.cjlee.io/>cjlee38</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>