<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Java Memory Model explained (feat. Effective Java, Item 78) - cjlee38</title>
<meta name=theme-color><meta name=description content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><meta name=author content="cjlee38"><link rel="preload stylesheet" as=style href=https://blog.cjlee.io/main.min.css><link rel=preload as=image href=https://blog.cjlee.io/theme.png><script defer src=https://blog.cjlee.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.cjlee.io/favicon.ico><link rel=apple-touch-icon href=https://blog.cjlee.io/apple-touch-icon.png><meta name=generator content="Hugo 0.127.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta itemprop=name content="Java Memory Model explained (feat. Effective Java, Item 78)"><meta itemprop=description content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><meta itemprop=datePublished content="2023-03-05T00:00:00+00:00"><meta itemprop=dateModified content="2023-03-05T00:00:00+00:00"><meta itemprop=wordCount content="2017"><meta itemprop=keywords content="Java,Jmm"><meta property="og:url" content="https://blog.cjlee.io/post/java-memory-model-explained/"><meta property="og:site_name" content="cjlee38"><meta property="og:title" content="Java Memory Model explained (feat. Effective Java, Item 78)"><meta property="og:description" content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-05T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Jmm"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Memory Model explained (feat. Effective Java, Item 78)"><meta name=twitter:description content="개요 이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.
public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } } 위 코드를 읽어보면, stopRequested 가 1초 뒤에 true 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다."><link rel=canonical href=https://blog.cjlee.io/post/java-memory-model-explained/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://blog.cjlee.io/>cjlee38</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/categories/>categories</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tags/>tags</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Java Memory Model explained (feat. Effective Java, Item 78)</h1><div class="text-sm antialiased opacity-60"><time>Mar 5, 2023</time></div></header><section><h3 id=개요>개요</h3><p>이펙티브 자바의 ‘아이템 78 공유 중인 가변 데이터는 동기화해 사용하라’ 에서는 멀티태스킹 환경에서 발생할 수 있는 동시성 문제들을 소개하고, 이에 대한 해결책을 제시한다. 아이템 78을 읽어본 사람이라면, 아래의 유명한 코드를 한 번쯤은 본 적이 있을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThread</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested)
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드를 읽어보면, <code>stopRequested</code> 가 1초 뒤에 <code>true</code> 로 바뀌었으므로 백그라운드 스레드는 종료되어야 할 것 같지만, 실제로 무한 루프를 돌게 된다. 책에서는 이를 OpenJDK의 경우 hoisting에 의한 것일 수 있다고 간단하게만 짚고 넘어간다. 또한, 이와 관련한 많은 자료들을 서치해보면 이는 <code>CPU cache</code>에 의한 문제라고 진단하고 넘어간다. 물론 틀린 말은 아니지만, 그 내부를 들여다보면 이는 간단하지 않은 문제다.</p><h3 id=jit-compiler>JIT compiler</h3><p>위 문제의 원인을 진단하기 위해서는, 우선 <code>JVM</code> 이 java 파일을 실행시키는 과정을 자세히 살펴보아야 한다. 우리가 <code>javac</code> 명령어를 통해 <code>.java</code> 확장자를 가진 파일을 컴파일하게 되면, 이는 곧바로 CPU에서 실행될 수 있는 코드로 변환되지 않는다. 해당 코드는 <code>JVM</code> 이 이해할 수 있는 <a href=https://en.wikipedia.org/wiki/Java_bytecode>Java Bytecode</a> 로 변환되고, 이를 <code>java</code> 명령어로 실행할 때가 되어서야 비로소 기계어로 번역되어 실행된다.</p><p>기계어로 번역되는 과정에서 <code>JVM</code>은 Java Bytecode를 CPU가 이해할 수 있는 <code>machine code</code>로 한줄씩 번역하게 된다. 이 과정에서 자주 참조하는 코드가 보이면(이 과정을 <code>warm-up</code> 이라고 표현하기도 한다.) 해당 코드를 통째로 컴파일해 실시간으로 번역하지 않고 컴파일을 진행한다.</p><h3 id=reordering>Reordering</h3><p>위와 같은 일련의 과정을 거치면서, JVM은 주어진 Java Bytecode에 대한 최적화를 진행한다. 일례로, 아래의 코드를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reordering</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increase</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 1;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> 2;
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 3;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위와 같은 코드를 작성하면 우리는 <code>increase</code> 메소드가 호출되었을 때 다음과 같은 순서로 동작하기를 기대한다.</p><ol><li>처음 <code>Reordering</code> 인스턴스를 생성하면, <code>a</code>와 <code>b</code>는 <code>0</code>으로 초기화된다.</li><li><code>increase</code> 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다.<ol><li><code>a</code>에 <code>1</code>을 더한다.</li><li><code>b</code>에 <code>2</code>를 더한다.</li><li><code>a</code>에 <code>3</code>을 더한다.</li></ol></li></ol><p>이러한 흐름은 사람에게는 자연스럽지만, 조금 더 기계친화적으로 흐름을 살펴보면 아래와 같이 동작한다.</p><ol><li><code>Reordering</code> 인스턴스에 대한 생성을 요청하면<ol><li><code>Reordering</code> 인스턴스의 클래스를 분석하고, 해당 인스턴스에 대한 공간을 할당받는다.</li><li>공간을 할당받은 뒤, <code>init</code> 메소드(생성자)를 실행하여 변수에 대한 초기화를 진행한다.</li></ol></li><li><code>increase</code> 메소드를 호출하면, 아래와 같은 흐름으로 연산을 진행한다.<ol><li>변수 <code>a</code>로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>1</code>을 더하는 연산을 수행한다.</li><li><code>1</code>을 더한 연산을 마친 후, <code>a</code> 변수가 위치한 공간에 값을 다시 write 한다.</li><li>변수 <code>b</code> 로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>2</code> 를 더하는 연산을 수행한다.</li><li><code>2</code>를 더한 연산을 마친 후, b 변수가 위치한 공간에 값을 다시 write 한다.</li><li>변수 <code>a</code>로부터 값을 읽어 CPU register에 올린다.</li><li>CPU register에 <code>3</code>을 더하는 연산을 수행한다.</li><li><code>3</code>을 더한 연산을 마친 후, <code>a</code> 변수가 위치한 공간에 값을 다시 write 한다.</li></ol></li></ol><p>내용이 조금 길긴 하지만, 자세히 읽어보면 그다지 어려운 내용이 아님을 알 수 있다. 그저, 값을 읽은 뒤 더하기 연산을 한 후, 그 값을 다시 원래 위치에 쓰기 연산을 했을 뿐이다. 하지만 위 과정을 다시 읽어보면, 더 효율적으로 계산할 수 있는 방법이 있다는 것 또한 알 수 있다.</p><p>즉, <code>2.1</code> 에 해당하는 읽기 연산을 한 후, <code>2.2</code>에 해당하는 덧셈 연산 직후에 곧바로 <code>2.7</code> 의 덧셈 연산을 연달아 수행하고, <code>2.8</code> 의 쓰기 연산을 이어나가면 명령어 수행 횟수를 줄일 수 있다. 이를 코드로 표현하면 아래와 같이 변경된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Reordering</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>increase</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 1;
</span></span><span style=display:flex><span>        a <span style=color:#f92672>+=</span> 3;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>+=</span> 2;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>심지어는 1과 3을 더하는 연산을 묶어서 차라리 4를 더해버리는 연산을 진행할 수도 있다. JVM은 위와 같이 코드의 순서를 변경하는 작업을 수행할 수 있으며, 이를 <code>reordering</code> 이라고 부른다.</p><p>이 <code>reordering</code> 은 JVM이 판단하기에 순서를 바꿔도 영향이 없는 코드에 대해 진행된다. 가령, <code>b += a;</code> 와 같이 <code>a</code>에 대한 덧셈 연산 결과를 바탕으로 <code>b</code>에 대한 연산을 수행하는 경우 해당 코드는 재배치되지 않는다.</p><h3 id=word-tearing>Word Tearing</h3><p>위에서 소개한 예제 뿐만 아니라, 또 다른 문제도 발생할 수 있다. 아이템 78의 첫 페이지 세 번째 문단을 살펴보면, 아래와 같이 이야기한다.</p><blockquote><p>언어 명세상 <code>long</code>과 <code>double</code> 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.(JLS, 174. 17.7)</p></blockquote><p><code>long</code>과 <code>double</code>은 왜 제외되는가 하고 보면, 두 개의 원시타입은 다른 타입들과 다르게 <code>64bit</code> 라는 특성을 가지고 있다. 다음의 코드를 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WordTearing</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> 0L;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 0x0000FFFF;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 0xFFFF0000;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드를 두 개의 스레드가 동시에 접근하여 수행하면 어떤 결과가 나타날까 ? 일반적으로 생각했을 때에는 <code>0x0000FFFF</code> 혹은 <code>0xFFFF0000</code> 둘 중 하나로 결과가 남을 것으로 기대해볼 수 있을 것이다. 하지만 32bit processor는 CPU register에 최대 32bit 만 올릴 수 있으므로, 총 64 bit 중 앞 쪽 32bit 의 쓰기연산과 뒤 쪽 32 bit의 쓰기 연산의 총 두 개의 연산으로 작업을 수행한다. 따라서 <code>0x0000FFFF</code>, <code>0xFFFF0000</code>, <code>0x00000000</code>, <code>0xFFFFFFFF</code> 의 총 4개의 결과가 가능한 결과 집합이 되고, 이러한 문제를 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.6>Word Tearing</a> 이라 부른다.</p><h3 id=jmm>JMM</h3><p>하지만 그렇다고 해서 위 코드들을 실제로 로컬환경에서 수행해봐도 문제가 발견되지 않을 수 있다. 이는 하드웨어 아키텍쳐의 차이로 인해 발생하는 것인데, 가령 64bit processor를 이용하는 경우에는 위와 같은 원자성 문제가 발생하지 않는다.</p><p><img src=2023-03-06-01-25-00.png alt></p><p>위 표는 각 CPU 아키텍쳐 별 optimization 지원 여부를 나타낸다. 가령, intel CPU의 경우 <code>load-load</code> 를 지원하지 않는다. <code>load-load</code> 는 하나의 변수를 읽고 다음 변수를 읽을 때 <code>reordering</code>이 발생하는지 여부를 의미한다. 한편, ARM CPU는 <code>load-load</code>를 지원하며, 이는 곧 두 개의 변수를 읽을 때 순서의 재배치가 발생할 수 있음을 의미한다.</p><blockquote><p>ARM 아키텍쳐의 CPU가 상대적으로 전력을 적게 소모하는 이유 중 하나이다.</p></blockquote><p><code>Java Memory Model</code>(이하 <code>JMM</code>) 은 특정 순간에 어떠한 필드를 읽었을 때 우리가 어떠한 값을 관찰할 수 있는지를 설명하는 모델이다. <code>JMM</code>은 <a href=https://preshing.com/20120930/weak-vs-strong-memory-models/>약한 메모리 모델</a>을 기반으로 설계되었기 때문에 각각의 CPU core가 바라볼 수 있는 값이 다를 수 있고, 따라서 이를 적절하게 제어하는 규칙에 대한 specification을 제공한다.</p><p>그리고 <code>JMM</code>에서 애플리케이션을 보호하는 개념 중 하나가 바로 오늘 중점적으로 다루게 될 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.4.5>happens-before</a> 관계이다. 여기서 한 가지 반드시 짚고 넘어가야 할 점은 <code>happens-before</code> 관계는 single thread를 기반으로 보장되었다는 점이다. 이를 다시 말하면 multi-thread 환경에서는 사용자가 어느정도는 의식적으로 염두에 두어야 한다는 말이다.</p><p>필드 영역에는 <code>final</code> , <code>volatile</code>, 메소드 영역에는 <code>synchronized</code>, <code>java.util.concurrent.locks.Lock</code> 를 이용해 이를 제어할 수 있으며, 해당 키워드/API 를 사용함으로서 JVM에게 동시성 이슈를 발생시킬 수 있는 최적화를 억제하도록 유도할 수 있다. 하지만 반대로 이야기하면 최적화를 진행하지 않음으로 인해 성능저하를 유발할 수도 있다는 뜻이 된다.</p><p>하나씩 살펴보자.</p><h3 id=volatile>volatile</h3><p>앞서 맨 처음 보았던 무한루프를 돌았던 코드와 비슷한 코드를 다시 한번 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataRace</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>ready);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> answer <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>        ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>두 개의 스레드가 동시에 thread1 메소드와 thread2 메소드를 수행하면 어떻게 될까? <code>assert</code> 부분이 통과할 수 있을까? 앞서 문제점들을 인지했다면, 위 코드는 실패할 가능성이 있다는 것을 알 것이다. 왜냐하면, thread2 의 <code>answer = 42;</code> 코드와 <code>ready = true;</code> 코드의 순서가 바뀌어서 <code>ready</code>가 먼저 <code>true</code>가 되버릴 수 있기 때문이다. 혹은, 앞서 보았던 예시와 마찬가지로 <code>ready</code> 변수가 CPU cache에 저장되어 <code>ready</code>가 <code>true</code>로 변경되었음에도 불구하고 여전히 <code>false</code>로 읽을 수도 있다.</p><p>이 문제를 해결하기 위해서는 아래와 같이 <code>ready</code> 변수에 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.3.1.4>volatile</a> 키워드를 사용할 수 있다.</p><p><code>volatile boolean ready = false;</code></p><p>JLS 에 나와있듯이, volatile 키워드가 붙은 변수는 모든 스레드가 ‘일관된 값’을 볼 수 있음을 보장해준다.(A <em>field may be declared <code>volatile</code>, in which case the Java Memory Model ensures that all threads see a consistent value for the variable</em>). 뿐만 아니라, volatile에 대한 쓰기 연산은 읽기연산에 선행(happens-before) 된다.</p><p>한 가지 더 주목할 점은, <code>volatile</code> 키워드를 <code>ready</code> 변수에만 붙여주었다는 점이다.이 또한 JMM이 <code>volatile</code> 변수에 대한 쓰기연산 이전에 선행된 쓰기 연산은, <code>reordering</code> 되지 않음을 보장하기 때문이다. (읽기 연산 또한 마찬가지로, volatile 변수에 대한 읽기가 선행되고 이후에 다른 변수에 대한 읽기가 진행됨이 보장된다.)</p><p>마지막으로, 앞서 보았던 Word Tearing 또한 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.7>발생하지 않는다.</a></p><blockquote><p>많은 사람들이 volatile 키워드는 메모리에 곧바로 쓸 수 있도록 하는 역할이라고 설명한다.
이것이 틀린 설명은 아니지만, JLS 상에서는 volatile 키워드가 ‘consistence’(일관성)을 유지하도록 보장한다고 설명한다. 즉, ‘명세’ 상으로는 항상 일관된 값을 관찰할 수 있어야 한다는 것이고, 이에 대한 구현(implementation)이 바로 메인 메모리에 대한 flush 라고 볼 수 있다.</p><p><strong>이는 <code>volatile</code>뿐만이 아닌 모든 <code>happens-before</code> 관계를 보장하는 (e.g. <code>synchronized</code>) 키워드에도 해당된다.</strong></p></blockquote><h3 id=synchronized>synchronized</h3><p><code>synchronized</code> 키워드 또한 <code>happens-before</code> 관계를 성립시키는 도구로 사용될 수 있다. 다음은 역시 마찬가지로 이펙티브 자바 아이템 78 에서 인용한 내용이다.</p><blockquote><p>많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.</p><p>… 중략</p><p>맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다. <strong>동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.</strong> 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.</p></blockquote><p>즉, <code>synchronized</code> 키워드에는 상호배제(mutual exclusion) 이외에도 <strong>스레드 간 통신</strong>(앞서 보았던 <code>happens-before</code>) 의 기능을 제공한다는 뜻이다.</p><p>위 <code>DataRace</code> 코드를 <code>synchronized</code> 키워드를 이용해 수정하면 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataRace</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> answer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() { <span style=color:#75715e>// &lt;- 데드락 발생 가능</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>ready);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> answer <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>        ready <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 코드를 곧바로 실행하면, 아마 thread1 메소드가 먼저 수행되는 경우에는 데드락이 발생하게 된다. 여기서는 “thread2 코드가 먼저 실행되었다” 라고 가정해보자. 그러면 아래와 같은 흐름으로 진행된다.</p><table><thead><tr><th style=text-align:center>스레드</th><th style=text-align:center>Thread 1</th><th style=text-align:center>Thread 2</th></tr></thead><tbody><tr><td style=text-align:center>실행</td><td style=text-align:center></td><td style=text-align:center>enter</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>answer = 42;</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>ready = true;</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>exit</td></tr><tr><td style=text-align:center></td><td style=text-align:center>enter</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>while (!ready);</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>assert answer = 42;</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center>exit</td><td style=text-align:center></td></tr></tbody></table><p>이펙티브 자바에서 설명했던 것과 마찬가지로, <code>monitor</code>를 통한 <code>critical section</code>의 진입/탈출 뿐만 아니라 <code>ready</code> 변수와 <code>answer</code> 변수에 대한 순서는 재배치되지 않고 순서대로 (<code>happens-before</code>)수행된다.</p><p><code>synchronized</code> 키워드와 관련해서 한 가지 더 짚고 넘어가고 싶은 부분이 있다. 가장 먼저 봤던 <code>StopThread</code> 클래스를 다시 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThread</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested) {
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;STOP ?&#34;</span>); <span style=color:#75715e>// (*)</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 코드에서, 주석으로 별표(*)를 달아놓은 부분을 새로이 추가하였다. 그리고 이 코드를 실행되면 어떻게 될까? 놀랍게도 이번에는 무한 루프를 돌지 않고 약 1초 뒤 종료된다. 출력문 하나를 추가하였을 뿐인데 왜 갑자기 1초뒤에 중단되었을까? 이는 <code>sout</code> 메소드를 살펴보면 알 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>println</span>(String x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>        print(x);
</span></span><span style=display:flex><span>        newLine();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>보는 바와 같이 <code>synchronized</code> 키워드가 존재한다. 그런데 여기서 한 가지 궁금증이 생긴다. <code>synchronized</code> 는 <code>this</code> 에 걸려있고, 이 <code>this</code>는 결국 <code>System.out</code> 인데, 왜 난데없이 전혀 관련 없어보이는 <code>stopRequested</code> 변수가 초기화되었을까 ? <a href=https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html>이는 synchronized block에 진입하는 순간, 해당 스레드가 볼 수 있는 모든 변수가 메모리로 flush 되었기 때문이다.</a></p><p>아래 코드는 이펙티브 자바에서 보인 <code>StopThread</code> 의 <code>synchronized</code> 키워드를 이용한 개선 버전인데, 이 부분도 자세히 보면 처음에는 “왜 <code>synchronized</code> 키워드를 붙인게 효과가 있지?” 라는 생각이 들었다가, 스레드 간 통신을 지원한다는 점을 떠올리면, 곧 고개를 끄덕일 수 있을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StopThreadSynchronized</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> stopRequested;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestStop</span>() {
</span></span><span style=display:flex><span>		stopRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>stopRequested</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> stopRequested;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread backgroundThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopRequested())
</span></span><span style=display:flex><span>                i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        backgroundThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        requestStop();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=final>final</h3><p>자바에서 <code>final</code>은 변수에 대한 재할당을 막는 역할로 널리 알려져 있다. 하지만 final 키워드 또한 <code>happens-before</code> 관계와 연관이 있다. 다음 코드를 보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnsafePublication</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>UnsafePublication</span>() {
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> 42;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> UnsafePublication instance;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread1</span>() {
</span></span><span style=display:flex><span>        instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UnsafePublication();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread2</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (instance <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>assert</span> instance.<span style=color:#a6e22e>a</span> <span style=color:#f92672>==</span> 42;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>흔히 싱글톤 패턴을 구현할 때 자주 볼 수 있는 코드 형태이다. (물론 동시성 문제를 고려하여 개선버전이 존재한다.) 마찬가지로 <code>thread1</code> 과 <code>thread2</code> 메소드가 동시에 수행되었을 때, 해당 코드는 항상 통과할 수 있을까?</p><p>정답은 ‘그렇지 않다’ 이다. 앞서 <code>Reordering</code> 절에서도 언급했듯이, <code>new</code> 키워드를 이용해 객체를 생성하는 행위는 두 가지로 구분된다.</p><ol><li>객체를 생성하기 위한 공간의 할당</li><li>객체 변수의 초기화</li></ol><p>따라서 1. 객체를 생성하기 위한 공간의 할당이 먼저 선행되고, <code>thread2</code> 메소드가 수행되는 경우, instance는 <code>null</code>을 가리키지 않으므로 if 절 안으로 진입하게 된다. 하지만, 객체 변수의 초기화 (<code>a = 42;</code>) 는 아직 수행되지 않았으므로(int 변수는 초기화되지 않으면, <code>0</code>을 갖는다.) 해당 assert 절은 실패하게 된다.</p><blockquote><p>참고로 파이썬에서는 생성자로 사용되는 <code>__init__</code> 메소드 이외에도 <code>__new__</code> 라는 메소드가 있는데, 이는 메모리를 할당받을 때 사용된다. 즉, <code>__init__</code> 메소드보다 반드시 선행된다.</p></blockquote><p>이를 해결하기 위한 방법으로 <code>final</code> 을 사용할 수 있다. 위 코드에서 <code>private final int a;</code> 과 같이 <code>final</code>을 붙여주게 되면, 생성자 메소드 <code>init</code> 이 끝난 직후에 <code>freeze</code> 라는 작업을 하게 된다. 생성자 내에서 또한 <code>happens-before</code> 관계가 보장되며, 생성자 체이닝(e.g. 부생성자 → 주생성자)이 발생한다면 최종 생성자가 끝나는 시점에 <code>freeze</code> 작업이 수행된다.</p><h3 id=마무리>마무리</h3><p>JVM의 구현체는 명세보다 더 엄격하게 관리한다. 따라서 구현체를 믿고 프로그램을 작성하다보면, Java 진영에서 이야기하는 <code>Cross-Platform Compatibility</code>, 즉 <code>Write Once, Run Anywhere</code> 이 어려워질 가능성이 높다. 따라서 보수적으로 코드를 작성해야 함에 유의하자.</p><hr><h3 id=reference>Reference</h3><ul><li><a href=https://youtu.be/qADk_tj4wY8>https://youtu.be/qADk_tj4wY8</a></li><li><a href=https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html>https://jenkov.com/tutorials/java-concurrency/java-happens-before-guarantee.html</a></li><li><a href=https://www.geeksforgeeks.org/happens-before-relationship-in-java/>https://www.geeksforgeeks.org/happens-before-relationship-in-java/</a></li><li><a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html>https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html</a></li><li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=jjoommnn&amp;logNo=130037479493">https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=jjoommnn&amp;logNo=130037479493</a></li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://blog.cjlee.io/tags/java>java</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://blog.cjlee.io/tags/jmm>jmm</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.cjlee.io/post/oop-is-psychotic-disorder/><span class=mr-1.5>←</span><span>객체지향은 정신병이다.</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://blog.cjlee.io/post/domain-layered-architecture/><span>도메인과 레이어드 아키텍처</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://blog.cjlee.io/>cjlee38</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>