<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>헷갈리는 WebClient Timeout | cjlee38</title>
<meta name=keywords content="spring,webclient,timeout"><meta name=description content="SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 RestTemplate 과 WebClient 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, WebClient 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.
WebClient 의 connection manager 는 기본 구현체로 reactor-netty 를, 그리고 reactor-netty 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다."><meta name=author content="cjlee38"><link rel=canonical href=https://blog.cjlee.io/post/webclient-timeout/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.cjlee.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cjlee.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.cjlee.io/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.cjlee.io/apple-touch-icon.png><link rel=mask-icon href=https://blog.cjlee.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.cjlee.io/post/webclient-timeout/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-5D28JSQJDK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5D28JSQJDK")}</script><meta property="og:title" content="헷갈리는 WebClient Timeout"><meta property="og:description" content="SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 RestTemplate 과 WebClient 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, WebClient 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.
WebClient 의 connection manager 는 기본 구현체로 reactor-netty 를, 그리고 reactor-netty 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.cjlee.io/post/webclient-timeout/"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-03-04T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-04T00:00:00+00:00"><meta property="og:site_name" content="cjlee38"><meta name=twitter:card content="summary"><meta name=twitter:title content="헷갈리는 WebClient Timeout"><meta name=twitter:description content="SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 RestTemplate 과 WebClient 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, WebClient 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.
WebClient 의 connection manager 는 기본 구현체로 reactor-netty 를, 그리고 reactor-netty 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.cjlee.io/post/"},{"@type":"ListItem","position":2,"name":"헷갈리는 WebClient Timeout","item":"https://blog.cjlee.io/post/webclient-timeout/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"헷갈리는 WebClient Timeout","name":"헷갈리는 WebClient Timeout","description":"SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 RestTemplate 과 WebClient 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, WebClient 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.\nWebClient 의 connection manager 는 기본 구현체로 reactor-netty 를, 그리고 reactor-netty 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다.","keywords":["spring","webclient","timeout"],"articleBody":"SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 RestTemplate 과 WebClient 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, WebClient 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.\nWebClient 의 connection manager 는 기본 구현체로 reactor-netty 를, 그리고 reactor-netty 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다. 따라서 WebClient 의 설정을 customize 하기 위해서는 netty, reactor-netty 의 옵션들을 알아야 한다.\n아직까지도 RestTemplate, 그리고 스프링 6 버전부터 도입된 RestClient 을 사용하는 경우도 많이 찾아볼수 있고, 해당 클라이언트에서 주로 사용되는 Apache HttpClient 5 버전에도 여러 옵션들이 존재하지만, 해당 내용까지 담기에는 너무 길어질 것 같아 다음에 알아보는 것으로 하고, 오늘은 WebClient, 즉 netty 쪽을 알아보자.\nWebClient (reactor-netty) 옵션 webClient 에서 주로 사용하는 옵션들은 다음과 같다. (물론 netty 자체에서도 제공하는 옵션들은 수없이 많다)\nval connectionProvider = ConnectionProvider.builder(\"my-pool\") .maxIdleTime(Duration.ofMillis(42)) .maxLifeTime(Duration.ofMillis(42)) .build(); val httpClient = HttpClient.create(connectionProvider) .doOnConnected { it.addHandlerLast(ReadTimeoutHandler(42, TimeUnit.MILLISECONDS)) .addHandlerFirst(WriteTimeoutHandler(42, TimeUnit.MILLISECONDS)) } .responseTimeout(Duration.ofMillis(42)) val webClient = WebClient.builder() .clientConnector(ReactorClientHttpConnector(httpClient)) .build() 하나씩 살펴보자.\nval connectionProvider = ConnectionProvider.builder(\"my-pool\") .maxIdleTime(Duration.ofMillis(42)) .maxLifeTime(Duration.ofMillis(42)) .build(); 가장 먼저 살펴볼 부분은 maxIdleTime 과 maxLifeTime 이다. ConnectionProvider 클래스는 개별의 connection 뿐만 아니라, connection pool 전략과 관련된 설정을 지정할 수 있다.\nmaxLifeTime 은 connection 의 전체 생명주기를 의미한다. 바꿔 말하면, connection 이 얼마나 사용되던, 사용되지 않았던 관계 없이, 한번 맺은 connection 을 얼마나 오랫동안 사용할 것인지를 의미한다. 예를 들어, maxLifeTime 이 10 초로 설정되어 있다면, server 에 한번 connection 을 맺고나서, 10초가 지나면 해당 connection 은 pool 에서 제거되고(기존에 해당 connection을 몇 번이고 사용했을지라도), 다시 요청을 보내려고 하면 새로운 connection 을 맺어서 요청을 보낸다.\nmaxIdleTime 은 idle 상태, 즉 사용되지 않은 connection 을 얼마나 이후에 pool 에서 제거할 것인지를 의미한다. 가령, maxIdleTime 이 5초라면, 0초에 요청을 보낸 뒤 5초가 될때까지 새로운 요청을 보내지 않으면 해당 connection 은 pool 에서 제거된다. 만약 3초에 요청을 보냈었다면, 8초가 될때까지는 살아있었을 것이다.\nval httpClient = HttpClient.create(connectionProvider) .doOnConnected { it.addHandlerLast(ReadTimeoutHandler(42, TimeUnit.MILLISECONDS)) .addHandlerFirst(WriteTimeoutHandler(42, TimeUnit.MILLISECONDS)) } .responseTimeout(Duration.ofMillis(42)) 두 번째로는 HttpClient 클래스에서 설정할 수 있는 옵션들로, ReadTimeoutHandler , WriteTimeoutHandler, 그리고 responseTimeout 이다.\nresponseTimeout 은 server 로 요청을 보내고 나서, 응답이 올 때까지 걸리는 대기 시간을 의미한다. 역시 예시를 들면, responseTimeout 이 3초라고 한다면, 0초에 요청을 보냈는데 server 에서 해당 요청을 처리하는데 4초가 걸렸다면 timeout 으로 exception 이 발생한다. 만약 3초 이내로 응답이 왔다면 exception 이 발생하지 않는다.\nReadTimeoutHandler 와 WriteTimeoutHandler 는 조금 특수한데, reactor 혹은 WebClient 와 관계없이, 순수하게 netty 의 TCP connection 자체(정확히는 netty 의 channel pipeline)에 거는 handler 다. WriteTimeoutHandler 는, 이름처럼 “쓰기”를 하는데 걸리는 시간으로, netty channel 에 write 를 요청했으나 제 시간에 완료가 되지 않는다면 exception 을 발생시킨다. ReadTimeoutHandler 또한 마찬가지로, netty channel 에 read 로 들어오는 시간이 설정된 값보다 넘었을 경우 exception 이 발생된다.\n여기까지 살펴보면, 각 옵션들과 그 의미가 모호하게 느껴지는 부분들이 있다. 가령, responseTimeout 과 ReadTimeoutHandler 는 비슷한 역할을 하는 것으로 보이기에 둘 중 아무거나 써도 될 것 같아 보이지만, 사실은 그렇지 않다.\nresponseTimeout vs ReadTimeoutHandler responseTimeout 과 ReadTimeoutHandler 는 둘 다 ‘응답’ 을 대기하는 속성이다. 결론부터 먼저 말하자면, ReadTimeoutHandler 는 특수한 상황이 아니라면 사용하는 것을 추천하지 않는다. 그 이유는, 두 개 timeout 의 tick 이 시작하는 시점이 다르기 때문이다.\n앞서 responseTimeout 은, “요청을 보내고 나서”, 응답이 올 때까지 걸리는 대기 시간이라고 언급했다. 따라서, 이 과정은 connection 을 생성 혹은 pool 에서 가져오거나,TLS handshake 를 하는 시간을 제외한 시간이다. 즉, 순수하게 HTTP level 에서 응답-요청까지의 interval 을 계산한 값이다.\n한편, ReadTimeoutHandler 의 timeout 은 connection 이 사용되려고 하는 시점부터 tick 이 진행된다. 바꿔 말하면, ReadTimeoutHandler 는 TCP 관점에서 timeout 을 측정한다. 따라서, TLS handshake 와 같은 부가적인 시간도 포함된다.\n즉, 그림으로 표현하면 아래와 같이 동작한다.\n이는 간단한 테스트 코드로도 실험해볼 수 있다. 먼저, 다음과 같이 아주 간단한 controller 코드를 작성하자.\n@PostMapping(\"/test\") fun test() { return \"Hello World!\" } 그리고 테스트코드는 다음과 같다.\nval httpClient = HttpClient.create() .doOnConnected { it.addHandlerLast(ReadTimeoutHandler(1000, TimeUnit.MILLISECONDS)) // (1) } .wiretap(\"my-wiretap\", LogLevel.INFO, AdvancedByteBufFormat.TEXTUAL) // netty log 활성화 .responseTimeout(Duration.ofMillis(1000)) // (2) val webClient = WebClient.builder() .clientConnector(ReactorClientHttpConnector(httpClient)) .build() val body = Mono.delay(Duration.ofMillis(2000)) .doOnNext { logger.info { \"body supplied\" } } .map { \"some-body\" } webClient.post() .uri(\"http://localhost:8080/test\") .body(body) .retrieve() .bodyToMono() .test() .expectNextCount(1) .verifyComplete() 위 코드를 보면, ReadTimeoutHandler 와 responseTimeout 을 둘 다 설정했는데, 실제로 테스트 코드를 실행할 때는 둘 중 하나를 주석처리 하면서 코드를 실행해보면 된다. body 를 일반적인 value 가 아닌, Mono 로 한번 감쌌다는 점에 주목하자. 즉, webClient 를 요청하려고 connection 을 맺은 뒤, 요청을 보낼 때 body 를 2초 뒤에 제공한다.\nresponseTimeout 만을 사용했을 때의 로그는 다음과 같다.\n2025-02-28 00:07:26.825 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70] REGISTERED 2025-02-28 00:07:26.864 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70] CONNECT: localhost/127.0.0.1:8080 2025-02-28 00:07:26.872 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] ACTIVE 2025-02-28 00:07:28.891 [parallel-1] [INFO] WebClientTest - body supplied 2025-02-28 00:07:28.901 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] WRITE: 167B POST /hello?sleep=0 HTTP/1.1 user-agent: ReactorNetty/1.2.1 host: localhost:8080 accept: */* Content-Type: text/plain;charset=UTF-8 content-length: 9 some-body 2025-02-28 00:07:28.902 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] FLUSH 2025-02-28 00:07:28.951 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] READ: 127B HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8 Content-Length: 13 Date: Thu, 27 Feb 2025 15:07:28 GMT Hello, world! 2025-02-28 00:07:28.965 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] READ COMPLETE 반대로, ReadTimeoutHandler 만 사용했을 때는 다음과 같이 ReadTimeoutException 이 발생한다.\n2025-02-27 23:55:03.117 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0] REGISTERED 2025-02-27 23:55:03.136 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0] CONNECT: localhost/127.0.0.1:8080 2025-02-27 23:55:03.140 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] ACTIVE 2025-02-27 23:55:04.149 [reactor-http-kqueue-2] [WARN] r.n.h.c.HttpClientConnect - [cd99e5c0-1, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] The connection observed an error io.netty.handler.timeout.ReadTimeoutException: null 2025-02-27 23:55:04.153 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] CLOSE 2025-02-27 23:55:04.154 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 ! R:localhost/127.0.0.1:8080] INACTIVE 2025-02-27 23:55:04.155 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 ! R:localhost/127.0.0.1:8080] UNREGISTERED reponseTimeout 은 body 까지 모두 전송하고 나서부터 측정을 했기 때문에 timeout 에 걸리지 않았다. 반면, ReadTimeoutHandler 는 body 를 전송(Mono.delay 로 body 가 생성되는 시간을 포함하여)하는 시간까지 포함했기 때문에 exception 이 발생한 것을 확인할 수 있다.\nreponseTimeout 과 관련한 이슈는 다음 링크 에서 확인해 볼 수 있다.\nReadTimeoutHandler vs maxIdleTime ReadTimeoutHandler 가 connection 생성 이후부터 timeout 을 측정한다면, 이번에는 maxIdleTime 이랑도 비교해볼 수 있다. ReadTimeoutHandler 의 timeout 이 1000ms , maxIdleTime 의 timeout 이 1000ms 라고 가정해보자. 응답을 받아서, 처리 후 connection pool 에 돌아가기까지 100ms 가 걸렸다면, connection pool 에서 900ms 뒤에 ReadTimouetHandler 로 인해 connection 이 제거될까 ? 그렇다면 maxIdleTime 은 의미가 없는거 아닐까 ? 그렇지는 않다.\n앞서 ReadTimeoutHandler 를 이야기할 때, “connection 이 생성된 시점” 이라고 말하지 않고, “connection 이 사용되려고 하는 시점” 이라고 표현하면서 동시에 bold 체를 사용한 이유가 있다.\nReadTimeoutHandler 자체만으로 보았을 때, timeout 은 connection 이 생성된 시점, 즉 channel 에 연결이 되는 시점부터 시작하는게 맞다. 따라서 connection pool 에 다시 되돌아가서 idle 상태로 대기중일 때에도 tick 이 계속 진행될 것이라고 생각되지만, 사실은 doOnConnected 에서 연결된 handler 는 한 번의 요청이 끝나면 제거된다.\n// reactor.netty.ReactorNetty.class // 아래 메소드를 호출한다 static void registerForClose(boolean shouldCleanupOnClose, String name, // ReadTimeoutHandler Connection context) { if (!shouldCleanupOnClose) { return; } context.onTerminate().subscribe(null, null, () -\u003e context.removeHandler(name)); } doOnConnected 는, “connection 이 생성되었을 때” 뿐만 아니라, 새로운 요청을 보내기 위해 connection pool 에서 idle connection 을 꺼내올때도 해당된다.\n즉, 정리하자면 요청을 보내기 위해 connection 을 꺼내거나 새로 생성한다. 이 때 ReadTimeoutHandler 가 등록된다. 요청이 끝난 이후 ReadTimeoutHandler 는 제거되고, connection 은 pool 로 되돌아가며, 이 때부터 maxIdleTime 의 tick 이 진행되는 흐름이다.\n자주 접하는 에러들 WebClient 를 사용하면서 서비스를 운영하다보면 위 에러를 자주 마주하게 된다.\nreactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response Connection Reset By peer 해당 에러가 발생하는 원인은 다양하지만, 만약 간헐적으로 발생한다면 주로 HTTP keep-alive 를 살펴볼 필요가 있다. (apache httpclient5 에서는 idleTime 을 HTTP keep alive 헤더를 바탕으로 동적으로 생성할 수 있는 API를 제공하지만, 아직 reactor netty 에서는 확인하지 못했다)\n에러가 발생하는 상황의 흔한 예시를 들면 다음과 같다.\nconnection idle time 이 해당 시간보다 길게 설정되어 있었고, 동시에 서버 측에서는 connection 에 대한 close 메세지(TCP FIN)를 보내주지 않고 조용히 connection 을 닫았다. 이 때, client 입장에서는 stale connection 을 이용해 요청을 보내지만, 서버측에서는 이미 닫힌 connection 이므로 TCP RST flag 를 응답한다 idle time 설정이 keep-alive 헤더보다 아주 조금 작게 설정되어 있어서, connection pool 에서 connection 을 꺼내고, request 를 보내기 아주 직전에 connection 이 종료되었다. 1번 케이스의 경우, 기본적으로 서버측에서 close 를 보내주는게 맞지만, client 입장에서는 idle time 을 낮게 잡는게 최선으로 보인다. reactor netty 레포지토리에 올라온 이슈 중 하나 가 이 예시에 해당한다.\n2번 케이스 또한, idle time 을 좀 더 작게 잡을 수도 있고, connection pool 전략 중 lifo 를 선택하는 것도 방법이다. (ConnectionProvider.builder(”pool-name”).lifo().build() )\nlifo 전략은 connection pool 에서 connection 을 꺼낼 때, “가장 최근에 사용된”(MRU, Most Recently Used) connection 을 사용하도록 한다. 가장 최근에 사용되었다는 것은, 가장 idleTime 이 짧다는(=더 오래 살 수 있다는) 의미이므로, 상대적으로 에러가 발생할 가능성이 적다.\nPrematureCloseException 을 던지는 위치를 찾아보면, netty 의 channelInactive 가 호출되었을 때, 즉 tcp 상에서는 RST flag 를 받았을 때, 혹은 예상치 못한 타이밍에 FIN flag 를 받았을 때 해당 에러를 던진다.\n// reactor.netty.http.client.HttpClientOperations.class // 해당 함수는 `channelInactive` 에서 호출된다. @Override protected void onInboundClose() { if (isInboundCancelled() || isInboundDisposed()) { listener().onStateChange(this, ConnectionObserver.State.DISCONNECTING); return; } listener().onStateChange(this, HttpClientState.RESPONSE_INCOMPLETE); if (responseState == null) { Throwable exception; if (markSentHeaderAndBody()) { exception = AbortedException.beforeSend(); } else if (markSentBody()) { exception = new PrematureCloseException(\"Connection has been closed BEFORE response, while sending request body\"); } else { exception = new PrematureCloseException(\"Connection prematurely closed BEFORE response\"); } listener().onUncaughtException(this, addOutboundErrorCause(exception, unprocessedOutboundError)); return; } super.onInboundError(addOutboundErrorCause(new PrematureCloseException(\"Connection prematurely closed DURING response\"), unprocessedOutboundError)); } 이 역시 다음의 간단한 코드로 netty 서버를 띄워서 테스트해볼 수 있다.\nfun main() { val bossGroup = NioEventLoopGroup() val workerGroup = NioEventLoopGroup() try { ServerBootstrap() .group(bossGroup, workerGroup) .channel(NioServerSocketChannel::class.java) .childHandler(object : ChannelInitializer() { override fun initChannel(ch: SocketChannel) { ch.pipeline().addLast(RudeServerHandler()) } }) .bind(8080).sync().channel().closeFuture().sync() } finally { bossGroup.shutdownGracefully() workerGroup.shutdownGracefully() } } private class RudeServerHandler : ChannelInboundHandlerAdapter() { override fun channelActive(ctx: ChannelHandlerContext) { // (1) ctx.close().await() } override fun channelRead(ctx: ChannelHandlerContext, msg: Any) { // (2) ctx.close().await() } override fun exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable) { cause.printStackTrace() ctx.close() } } main 부분은 서버를 띄우는 부분이라 크게 볼 건 없고, RudeServerHandler 의 channelActive , 그리고 channelRead 부분을 살펴보면 된다. channelActive 함수는 connection 이 연결되었을 때, 그리고 channelRead 는 데이터를 읽을 때(모든 데이터는 아님) 호출된다. 그리고 이 타이밍에, channel(connection) 을 강제로 닫아버리고 있다.(ctx.close().await()). 둘 다 있을 필요는 없으므로, 하나씩 주석처리를 해가며 테스트를 해보면 된다. 먼저, channelRead 쪽 close 만 사용했을 때(=channelActive 쪽 코드를 주석처리 했을 때) 를 살펴보자.\n예상한대로, reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response 에러가 발생한다. 이 때의 wireshark packet 을 보면 다음과 같다.\n1~3 번째 packet(2380, 2381, 2383) 은 tcp 3-way handshake 로, 정상적인 connection 을 맺었다. 4번째 packet(2385) 은 tcp 흐름제어(sliding window)와 관련된 packet 이므로 무시하자. 5번째 packet(2392) 에서, HTTP 요청을 정상적으로 보냈고, 6번째 packet(2393) 은 해당 데이터를 정상적으로 받았음을 의미한다.\n7번째(2404)부터, 갑작스럽게 server 에서 client 측으로 FIN 을 보내면서, connection 을 닫는다. client 입장에서는 request 를 제대로 보냈으나 갑작스럽게 FIN 으로 connection 을 닫으라는 메세지를 받았으므로, 예상치 못한 상황이라 예외를 던진다. 에러 메세지 Connection prematurely closed BEFORE response 가 어떤 의미인지 이해가 될 것이다.\n이번에는 반대로 channelActive 쪽 close 만 사용해보자. 이번에는 기존과 달리 Connection reset by peer 에러가 발생한다. 이 또한 packet 을 살펴보자.\n1~4 번째 packet(2239, 2240, 2242, 2244) 은 기존과 동일하게, 3-way handshake 이후 sliding window 를 위한 packet 을 주고받았다. 5번째 packet(2251) 에서,TCP 연결을 맺자마자, server 측에서 FIN 을 보내 connection 종료를 보내는 것을 볼 수 있다. 그러나 7번째 packet(2257) 에서 client 는 이미 종료된 connection 에 대해 요청을 보내버렸고, server 측에서는 “난 이미 종료했는데?” 라며 RST 플래그를 응답한것이다.\n6번째 packet 에서, server 의 FIN 에 client 가 ACK 으로 응답했음에도 요청을 보낸 이유는 비동기적인 측면이 원인으로 추측하고 있다. reactor netty 에서는 요청을 한창 보내려고 준비중인 와중에, netty framework 가 우선 ACK 을 먼저 응답하고, 요청을 중단하려고 보니까 이미 데이터는 요청된 것으로 보인다.\n만약 본인이 webClient 를 사용하다가, 해당 에러가 발생하는데 정확히 무슨 원인인지 파악하기 어렵다면 위 내용을 참고하여 다음의 공식문서를 참고하는 것도 도움이 될 것 같다.\nhttps://projectreactor.io/docs/netty/release/reference/faq.html#faq.connection-closed\n","wordCount":"1921","inLanguage":"en","datePublished":"2025-03-04T00:00:00Z","dateModified":"2025-03-04T00:00:00Z","author":{"@type":"Person","name":"cjlee38"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cjlee.io/post/webclient-timeout/"},"publisher":{"@type":"Organization","name":"cjlee38","logo":{"@type":"ImageObject","url":"https://blog.cjlee.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cjlee.io/ accesskey=h title="Home (Alt + H)"><img src=https://blog.cjlee.io/assets/icon.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.cjlee.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://blog.cjlee.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.cjlee.io/>Home</a>&nbsp;»&nbsp;<a href=https://blog.cjlee.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">헷갈리는 WebClient Timeout</h1><div class=post-meta><span title='2025-03-04 00:00:00 +0000 UTC'>March 4, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;cjlee38&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/webclient-timeout/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#webclient-reactor-netty-%ec%98%b5%ec%85%98 aria-label="WebClient (reactor-netty) 옵션">WebClient (reactor-netty) 옵션</a><ul><li><a href=#responsetimeout-vs-readtimeouthandler aria-label="responseTimeout vs ReadTimeoutHandler">responseTimeout vs ReadTimeoutHandler</a></li><li><a href=#readtimeouthandler-vs-maxidletime aria-label="ReadTimeoutHandler vs maxIdleTime">ReadTimeoutHandler vs maxIdleTime</a></li><li><a href=#%ec%9e%90%ec%a3%bc-%ec%a0%91%ed%95%98%eb%8a%94-%ec%97%90%eb%9f%ac%eb%93%a4 aria-label="자주 접하는 에러들">자주 접하는 에러들</a></li></ul></li></ul></div></details></div><div class=post-content><p>SpringBoot 환경에서 HTTP 요청을 보낼 때 주로 사용하는 client 는 <code>RestTemplate</code> 과 <code>WebClient</code> 가 있다. RestTemplate 은 Spring 3.0 부터 포함된 client 로, mvc 환경에서 blocking I/O 방식으로 요청을 보낼 때 주로 사용되어왔고, <code>WebClient</code> 는 (비교적 ?) 최신인 5.0 부터 도입되어, webflux 환경에서 non-blocking I/O 로 요청을 보낼 때 애용되어왔다.</p><p><code>WebClient</code> 의 connection manager 는 기본 구현체로 <code>reactor-netty</code> 를, 그리고 <code>reactor-netty</code> 는 netty 의 wrapper 로, 실상 HTTP 요청을 보내는 connection 을 관리하는 주체는 netty framework 를 사용한다. 따라서 <code>WebClient</code> 의 설정을 customize 하기 위해서는 netty, reactor-netty 의 옵션들을 알아야 한다.</p><p>아직까지도 <code>RestTemplate</code>, 그리고 스프링 6 버전부터 도입된 <code>RestClient</code> 을 사용하는 경우도 많이 찾아볼수 있고, 해당 클라이언트에서 주로 사용되는 Apache HttpClient 5 버전에도 여러 옵션들이 존재하지만, 해당 내용까지 담기에는 너무 길어질 것 같아 다음에 알아보는 것으로 하고, 오늘은 <code>WebClient</code>, 즉 netty 쪽을 알아보자.</p><h2 id=webclient-reactor-netty-옵션>WebClient (reactor-netty) 옵션<a hidden class=anchor aria-hidden=true href=#webclient-reactor-netty-옵션>#</a></h2><p>webClient 에서 주로 사용하는 옵션들은 다음과 같다. (물론 netty 자체에서도 제공하는 <a href=https://netty.io/4.1/api/index.html?io/netty/channel/ChannelOption.html>옵션들은 수없이 많다</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> connectionProvider = <span style=color:#a6e22e>ConnectionProvider</span>.builder(<span style=color:#e6db74>&#34;my-pool&#34;</span>)
</span></span><span style=display:flex><span>	.maxIdleTime(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span><span style=display:flex><span>	.maxLifeTime(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span><span style=display:flex><span>	.build();
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> httpClient = <span style=color:#a6e22e>HttpClient</span>.create(connectionProvider)
</span></span><span style=display:flex><span>	.doOnConnected {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>it</span>.addHandlerLast(ReadTimeoutHandler(<span style=color:#ae81ff>42</span>, <span style=color:#a6e22e>TimeUnit</span>.MILLISECONDS))
</span></span><span style=display:flex><span>			.addHandlerFirst(WriteTimeoutHandler(<span style=color:#ae81ff>42</span>, <span style=color:#a6e22e>TimeUnit</span>.MILLISECONDS))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>   .responseTimeout(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> webClient = <span style=color:#a6e22e>WebClient</span>.builder()
</span></span><span style=display:flex><span>	.clientConnector(ReactorClientHttpConnector(httpClient))
</span></span><span style=display:flex><span>	.build()
</span></span></code></pre></div><p>하나씩 살펴보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> connectionProvider = <span style=color:#a6e22e>ConnectionProvider</span>.builder(<span style=color:#e6db74>&#34;my-pool&#34;</span>)
</span></span><span style=display:flex><span>	.maxIdleTime(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span><span style=display:flex><span>	.maxLifeTime(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span><span style=display:flex><span>	.build();
</span></span></code></pre></div><p>가장 먼저 살펴볼 부분은 <code>maxIdleTime</code> 과 <code>maxLifeTime</code> 이다. <code>ConnectionProvider</code> 클래스는 개별의 connection 뿐만 아니라, connection pool 전략과 관련된 설정을 지정할 수 있다.</p><p><code>maxLifeTime</code> 은 connection 의 전체 생명주기를 의미한다. 바꿔 말하면, connection 이 얼마나 사용되던, 사용되지 않았던 관계 없이, 한번 맺은 connection 을 얼마나 오랫동안 사용할 것인지를 의미한다. 예를 들어, <code>maxLifeTime</code> 이 10 초로 설정되어 있다면, server 에 한번 connection 을 맺고나서, 10초가 지나면 해당 connection 은 pool 에서 제거되고(기존에 해당 connection을 몇 번이고 사용했을지라도), 다시 요청을 보내려고 하면 새로운 connection 을 맺어서 요청을 보낸다.</p><p><code>maxIdleTime</code> 은 idle 상태, 즉 사용되지 않은 connection 을 얼마나 이후에 pool 에서 제거할 것인지를 의미한다. 가령, <code>maxIdleTime</code> 이 5초라면, 0초에 요청을 보낸 뒤 5초가 될때까지 새로운 요청을 보내지 않으면 해당 connection 은 pool 에서 제거된다. 만약 3초에 요청을 보냈었다면, 8초가 될때까지는 살아있었을 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> httpClient = <span style=color:#a6e22e>HttpClient</span>.create(connectionProvider)
</span></span><span style=display:flex><span>	.doOnConnected {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>it</span>.addHandlerLast(ReadTimeoutHandler(<span style=color:#ae81ff>42</span>, <span style=color:#a6e22e>TimeUnit</span>.MILLISECONDS))
</span></span><span style=display:flex><span>			.addHandlerFirst(WriteTimeoutHandler(<span style=color:#ae81ff>42</span>, <span style=color:#a6e22e>TimeUnit</span>.MILLISECONDS))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>   .responseTimeout(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>42</span>))
</span></span></code></pre></div><p>두 번째로는 <code>HttpClient</code> 클래스에서 설정할 수 있는 옵션들로, <code>ReadTimeoutHandler</code> , <code>WriteTimeoutHandler</code>, 그리고 <code>responseTimeout</code> 이다.</p><p><code>responseTimeout</code> 은 server 로 요청을 보내고 나서, 응답이 올 때까지 걸리는 대기 시간을 의미한다. 역시 예시를 들면, <code>responseTimeout</code> 이 3초라고 한다면, 0초에 요청을 보냈는데 server 에서 해당 요청을 처리하는데 4초가 걸렸다면 timeout 으로 exception 이 발생한다. 만약 3초 이내로 응답이 왔다면 exception 이 발생하지 않는다.</p><p><code>ReadTimeoutHandler</code> 와 <code>WriteTimeoutHandler</code> 는 조금 특수한데, reactor 혹은 WebClient 와 관계없이, 순수하게 netty 의 TCP connection 자체(정확히는 netty 의 channel pipeline)에 거는 handler 다. <code>WriteTimeoutHandler</code> 는, 이름처럼 “쓰기”를 하는데 걸리는 시간으로, netty channel 에 write 를 요청했으나 제 시간에 완료가 되지 않는다면 exception 을 발생시킨다. <code>ReadTimeoutHandler</code> 또한 마찬가지로, netty channel 에 read 로 들어오는 시간이 설정된 값보다 넘었을 경우 exception 이 발생된다.</p><p>여기까지 살펴보면, 각 옵션들과 그 의미가 모호하게 느껴지는 부분들이 있다. 가령, <code>responseTimeout</code> 과 <code>ReadTimeoutHandler</code> 는 비슷한 역할을 하는 것으로 보이기에 둘 중 아무거나 써도 될 것 같아 보이지만, 사실은 그렇지 않다.</p><h3 id=responsetimeout-vs-readtimeouthandler>responseTimeout vs ReadTimeoutHandler<a hidden class=anchor aria-hidden=true href=#responsetimeout-vs-readtimeouthandler>#</a></h3><p><code>responseTimeout</code> 과 <code>ReadTimeoutHandler</code> 는 둘 다 ‘응답’ 을 대기하는 속성이다. 결론부터 먼저 말하자면, <code>ReadTimeoutHandler</code> 는 특수한 상황이 아니라면 사용하는 것을 추천하지 않는다. 그 이유는, 두 개 timeout 의 tick 이 시작하는 시점이 다르기 때문이다.</p><p>앞서 <code>responseTimeout</code> 은, “요청을 보내고 나서”, 응답이 올 때까지 걸리는 대기 시간이라고 언급했다. 따라서, 이 과정은 connection 을 생성 혹은 pool 에서 가져오거나,TLS handshake 를 하는 시간을 제외한 시간이다. 즉, 순수하게 <strong>HTTP level 에서 응답-요청까지의 interval</strong> 을 계산한 값이다.</p><p>한편, <code>ReadTimeoutHandler</code> 의 timeout 은 connection 이 <strong>사용되려고 하는 시점</strong>부터 tick 이 진행된다. 바꿔 말하면, <code>ReadTimeoutHandler</code> 는 TCP 관점에서 timeout 을 측정한다. 따라서, TLS handshake 와 같은 부가적인 시간도 포함된다.</p><p>즉, 그림으로 표현하면 아래와 같이 동작한다.</p><p><img loading=lazy src=./image1.png alt=image.png></p><p>이는 간단한 테스트 코드로도 실험해볼 수 있다. 먼저, 다음과 같이 아주 간단한 controller 코드를 작성하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/test&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello World!&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>그리고 테스트코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> httpClient = <span style=color:#a6e22e>HttpClient</span>.create()
</span></span><span style=display:flex><span>	.doOnConnected {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>it</span>.addHandlerLast(ReadTimeoutHandler(<span style=color:#ae81ff>1000</span>, <span style=color:#a6e22e>TimeUnit</span>.MILLISECONDS)) <span style=color:#75715e>// (1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	.wiretap(<span style=color:#e6db74>&#34;my-wiretap&#34;</span>, <span style=color:#a6e22e>LogLevel</span>.INFO, <span style=color:#a6e22e>AdvancedByteBufFormat</span>.TEXTUAL) <span style=color:#75715e>// netty log 활성화
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	.responseTimeout(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>1000</span>)) <span style=color:#75715e>// (2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> webClient = <span style=color:#a6e22e>WebClient</span>.builder()
</span></span><span style=display:flex><span>	.clientConnector(ReactorClientHttpConnector(httpClient))
</span></span><span style=display:flex><span>	.build()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> body = <span style=color:#a6e22e>Mono</span>.delay(<span style=color:#a6e22e>Duration</span>.ofMillis(<span style=color:#ae81ff>2000</span>))
</span></span><span style=display:flex><span>	.doOnNext { logger.info { <span style=color:#e6db74>&#34;body supplied&#34;</span> } }
</span></span><span style=display:flex><span>	.map { <span style=color:#e6db74>&#34;some-body&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>webClient.post()
</span></span><span style=display:flex><span>	.uri(<span style=color:#e6db74>&#34;http://localhost:8080/test&#34;</span>)
</span></span><span style=display:flex><span>	.body(body)
</span></span><span style=display:flex><span>	.retrieve()
</span></span><span style=display:flex><span>	.bodyToMono&lt;String&gt;()
</span></span><span style=display:flex><span>	.test()
</span></span><span style=display:flex><span>	.expectNextCount(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	.verifyComplete()
</span></span></code></pre></div><p>위 코드를 보면, <code>ReadTimeoutHandler</code> 와 <code>responseTimeout</code> 을 둘 다 설정했는데, 실제로 테스트 코드를 실행할 때는 둘 중 하나를 주석처리 하면서 코드를 실행해보면 된다. <code>body</code> 를 일반적인 value 가 아닌, <code>Mono</code> 로 한번 감쌌다는 점에 주목하자. 즉, webClient 를 요청하려고 connection 을 맺은 뒤, 요청을 보낼 때 body 를 2초 뒤에 제공한다.</p><p><code>responseTimeout</code> 만을 사용했을 때의 로그는 다음과 같다.</p><pre tabindex=0><code>2025-02-28 00:07:26.825 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70] REGISTERED 
2025-02-28 00:07:26.864 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70] CONNECT: localhost/127.0.0.1:8080 
2025-02-28 00:07:26.872 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] ACTIVE 
2025-02-28 00:07:28.891 [parallel-1] [INFO] WebClientTest - body supplied 
2025-02-28 00:07:28.901 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] WRITE: 167B POST /hello?sleep=0 HTTP/1.1
user-agent: ReactorNetty/1.2.1
host: localhost:8080
accept: */*
Content-Type: text/plain;charset=UTF-8
content-length: 9

some-body 
2025-02-28 00:07:28.902 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] FLUSH 
2025-02-28 00:07:28.951 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70-1, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] READ: 127B HTTP/1.1 200 
Content-Type: text/plain;charset=UTF-8
Content-Length: 13
Date: Thu, 27 Feb 2025 15:07:28 GMT

Hello, world! 
2025-02-28 00:07:28.965 [reactor-http-kqueue-2] [INFO] my-wiretap - [5c518a70, L:/127.0.0.1:64410 - R:localhost/127.0.0.1:8080] READ COMPLETE 
</code></pre><p>반대로, <code>ReadTimeoutHandler</code> 만 사용했을 때는 다음과 같이 <code>ReadTimeoutException</code> 이 발생한다.</p><pre tabindex=0><code>2025-02-27 23:55:03.117 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0] REGISTERED 
2025-02-27 23:55:03.136 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0] CONNECT: localhost/127.0.0.1:8080 
2025-02-27 23:55:03.140 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] ACTIVE 
2025-02-27 23:55:04.149 [reactor-http-kqueue-2] [WARN] r.n.h.c.HttpClientConnect - [cd99e5c0-1, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] The connection observed an error 
io.netty.handler.timeout.ReadTimeoutException: null
2025-02-27 23:55:04.153 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 - R:localhost/127.0.0.1:8080] CLOSE 
2025-02-27 23:55:04.154 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 ! R:localhost/127.0.0.1:8080] INACTIVE 
2025-02-27 23:55:04.155 [reactor-http-kqueue-2] [INFO] my-wiretap - [cd99e5c0-1, L:/127.0.0.1:63968 ! R:localhost/127.0.0.1:8080] UNREGISTERED 
</code></pre><p><code>reponseTimeout</code> 은 body 까지 모두 전송하고 나서부터 측정을 했기 때문에 timeout 에 걸리지 않았다. 반면, <code>ReadTimeoutHandler</code> 는 body 를 전송(Mono.delay 로 body 가 생성되는 시간을 포함하여)하는 시간까지 포함했기 때문에 exception 이 발생한 것을 확인할 수 있다.</p><p><code>reponseTimeout</code> 과 관련한 이슈는 <a href=https://github.com/reactor/reactor-netty/issues/1159>다음 링크</a> 에서 확인해 볼 수 있다.</p><h3 id=readtimeouthandler-vs-maxidletime>ReadTimeoutHandler vs maxIdleTime<a hidden class=anchor aria-hidden=true href=#readtimeouthandler-vs-maxidletime>#</a></h3><p><code>ReadTimeoutHandler</code> 가 connection 생성 이후부터 timeout 을 측정한다면, 이번에는 <code>maxIdleTime</code> 이랑도 비교해볼 수 있다. <code>ReadTimeoutHandler</code> 의 timeout 이 1000ms , <code>maxIdleTime</code> 의 timeout 이 1000ms 라고 가정해보자. 응답을 받아서, 처리 후 connection pool 에 돌아가기까지 100ms 가 걸렸다면, connection pool 에서 900ms 뒤에 <code>ReadTimouetHandler</code> 로 인해 connection 이 제거될까 ? 그렇다면 <code>maxIdleTime</code> 은 의미가 없는거 아닐까 ? 그렇지는 않다.</p><p>앞서 <code>ReadTimeoutHandler</code> 를 이야기할 때, “connection 이 생성된 시점” 이라고 말하지 않고, “connection 이 사용되려고 하는 시점” 이라고 표현하면서 동시에 bold 체를 사용한 이유가 있다.</p><p><code>ReadTimeoutHandler</code> 자체만으로 보았을 때, timeout 은 connection 이 생성된 시점, 즉 channel 에 연결이 되는 시점부터 시작하는게 맞다. 따라서 connection pool 에 다시 되돌아가서 idle 상태로 대기중일 때에도 tick 이 계속 진행될 것이라고 생각되지만, 사실은 <code>doOnConnected</code> 에서 연결된 handler 는 한 번의 요청이 끝나면 제거된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reactor.netty.ReactorNetty.class</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 아래 메소드를 호출한다</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerForClose</span>(<span style=color:#66d9ef>boolean</span> shouldCleanupOnClose,
</span></span><span style=display:flex><span>		String name, <span style=color:#75715e>// ReadTimeoutHandler</span>
</span></span><span style=display:flex><span>		Connection context) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>shouldCleanupOnClose) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	context.<span style=color:#a6e22e>onTerminate</span>().<span style=color:#a6e22e>subscribe</span>(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>, () <span style=color:#f92672>-&gt;</span> context.<span style=color:#a6e22e>removeHandler</span>(name));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>doOnConnected</code> 는, “connection 이 생성되었을 때” 뿐만 아니라, 새로운 요청을 보내기 위해 connection pool 에서 idle connection 을 꺼내올때도 해당된다.</p><p>즉, 정리하자면 요청을 보내기 위해 connection 을 꺼내거나 새로 생성한다. 이 때 <code>ReadTimeoutHandler</code> 가 등록된다. 요청이 끝난 이후 <code>ReadTimeoutHandler</code> 는 제거되고, connection 은 pool 로 되돌아가며, 이 때부터 <code>maxIdleTime</code> 의 tick 이 진행되는 흐름이다.</p><h3 id=자주-접하는-에러들>자주 접하는 에러들<a hidden class=anchor aria-hidden=true href=#자주-접하는-에러들>#</a></h3><p>WebClient 를 사용하면서 서비스를 운영하다보면 위 에러를 자주 마주하게 된다.</p><ul><li><code>reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response</code></li><li><code>Connection Reset By peer</code></li></ul><p>해당 에러가 발생하는 원인은 다양하지만, 만약 간헐적으로 발생한다면 주로 HTTP keep-alive 를 살펴볼 필요가 있다. (<code>apache httpclient5</code> 에서는 idleTime 을 HTTP keep alive 헤더를 바탕으로 동적으로 생성할 수 있는 API를 제공하지만, 아직 reactor netty 에서는 확인하지 못했다)</p><p>에러가 발생하는 상황의 흔한 예시를 들면 다음과 같다.</p><ul><li>connection idle time 이 해당 시간보다 길게 설정되어 있었고, 동시에 서버 측에서는 connection 에 대한 close 메세지(<code>TCP FIN</code>)를 보내주지 않고 조용히 connection 을 닫았다. 이 때, client 입장에서는 stale connection 을 이용해 요청을 보내지만, 서버측에서는 이미 닫힌 connection 이므로 <code>TCP RST</code> flag 를 응답한다</li><li>idle time 설정이 keep-alive 헤더보다 아주 조금 작게 설정되어 있어서, connection pool 에서 connection 을 꺼내고, request 를 보내기 아주 직전에 connection 이 종료되었다.</li></ul><p>1번 케이스의 경우, 기본적으로 서버측에서 close 를 보내주는게 맞지만, client 입장에서는 idle time 을 낮게 잡는게 최선으로 보인다. <a href=https://github.com/reactor/reactor-netty/issues/764#issuecomment-1011373248>reactor netty 레포지토리에 올라온 이슈 중 하나</a> 가 이 예시에 해당한다.</p><p>2번 케이스 또한, idle time 을 좀 더 작게 잡을 수도 있고, connection pool 전략 중 <code>lifo</code> 를 선택하는 것도 방법이다. (<code>ConnectionProvider.builder(”pool-name”).lifo().build()</code> )</p><p>lifo 전략은 connection pool 에서 connection 을 꺼낼 때, “가장 최근에 사용된”(MRU, Most Recently Used) connection 을 사용하도록 한다. 가장 최근에 사용되었다는 것은, 가장 idleTime 이 짧다는(=더 오래 살 수 있다는) 의미이므로, 상대적으로 에러가 발생할 가능성이 적다.</p><p><code>PrematureCloseException</code> 을 던지는 위치를 찾아보면, netty 의 <code>channelInactive</code> 가 호출되었을 때, 즉 tcp 상에서는 <code>RST</code> flag 를 받았을 때, 혹은 예상치 못한 타이밍에 <code>FIN</code> flag 를 받았을 때 해당 에러를 던진다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reactor.netty.http.client.HttpClientOperations.class </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 해당 함수는 `channelInactive` 에서 호출된다.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onInboundClose</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isInboundCancelled() <span style=color:#f92672>||</span> isInboundDisposed()) {
</span></span><span style=display:flex><span>		listener().<span style=color:#a6e22e>onStateChange</span>(<span style=color:#66d9ef>this</span>, ConnectionObserver.<span style=color:#a6e22e>State</span>.<span style=color:#a6e22e>DISCONNECTING</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	listener().<span style=color:#a6e22e>onStateChange</span>(<span style=color:#66d9ef>this</span>, HttpClientState.<span style=color:#a6e22e>RESPONSE_INCOMPLETE</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (responseState <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>		Throwable exception;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (markSentHeaderAndBody()) {
</span></span><span style=display:flex><span>			exception <span style=color:#f92672>=</span> AbortedException.<span style=color:#a6e22e>beforeSend</span>();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (markSentBody()) {
</span></span><span style=display:flex><span>			exception <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PrematureCloseException(<span style=color:#e6db74>&#34;Connection has been closed BEFORE response, while sending request body&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			exception <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PrematureCloseException(<span style=color:#e6db74>&#34;Connection prematurely closed BEFORE response&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		listener().<span style=color:#a6e22e>onUncaughtException</span>(<span style=color:#66d9ef>this</span>, addOutboundErrorCause(exception, unprocessedOutboundError));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onInboundError</span>(addOutboundErrorCause(<span style=color:#66d9ef>new</span> PrematureCloseException(<span style=color:#e6db74>&#34;Connection prematurely closed DURING response&#34;</span>),
</span></span><span style=display:flex><span>			unprocessedOutboundError));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 역시 다음의 간단한 코드로 netty 서버를 띄워서 테스트해볼 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> bossGroup = NioEventLoopGroup()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>val</span> workerGroup = NioEventLoopGroup()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>		ServerBootstrap()
</span></span><span style=display:flex><span>			.group(bossGroup, workerGroup)
</span></span><span style=display:flex><span>			.channel(NioServerSocketChannel<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.java)
</span></span><span style=display:flex><span>			.childHandler(<span style=color:#66d9ef>object</span> <span style=color:#960050;background-color:#1e0010>: </span><span style=color:#a6e22e>ChannelInitializer</span>&lt;SocketChannel&gt;() {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>initChannel</span>(ch: SocketChannel) {
</span></span><span style=display:flex><span>					ch.pipeline().addLast(RudeServerHandler())
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			})
</span></span><span style=display:flex><span>			.bind(<span style=color:#ae81ff>8080</span>).sync().channel().closeFuture().sync()
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>		bossGroup.shutdownGracefully()
</span></span><span style=display:flex><span>		workerGroup.shutdownGracefully()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RudeServerHandler</span> : ChannelInboundHandlerAdapter() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>channelActive</span>(ctx: ChannelHandlerContext) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// (1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		ctx.close().await()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>channelRead</span>(ctx: ChannelHandlerContext, msg: Any) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// (2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		ctx.close().await()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>exceptionCaught</span>(ctx: ChannelHandlerContext, cause: Throwable) {
</span></span><span style=display:flex><span>		cause.printStackTrace()
</span></span><span style=display:flex><span>		ctx.close()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>main 부분은 서버를 띄우는 부분이라 크게 볼 건 없고, <code>RudeServerHandler</code> 의 <code>channelActive</code> , 그리고 <code>channelRead</code> 부분을 살펴보면 된다. <code>channelActive</code> 함수는 connection 이 연결되었을 때, 그리고 <code>channelRead</code> 는 데이터를 읽을 때(모든 데이터는 아님) 호출된다. 그리고 이 타이밍에, channel(connection) 을 강제로 닫아버리고 있다.(<code>ctx.close().await()</code>). 둘 다 있을 필요는 없으므로, 하나씩 주석처리를 해가며 테스트를 해보면 된다. 먼저, <code>channelRead</code> 쪽 close 만 사용했을 때(=channelActive 쪽 코드를 주석처리 했을 때) 를 살펴보자.</p><p>예상한대로, <code>reactor.netty.http.client.PrematureCloseException: Connection prematurely closed BEFORE response</code> 에러가 발생한다. 이 때의 wireshark packet 을 보면 다음과 같다.</p><p><img loading=lazy src=./image2.png alt=image.png></p><p>1~3 번째 packet(2380, 2381, 2383) 은 tcp 3-way handshake 로, 정상적인 connection 을 맺었다. 4번째 packet(2385) 은 tcp 흐름제어(sliding window)와 관련된 packet 이므로 무시하자. 5번째 packet(2392) 에서, HTTP 요청을 정상적으로 보냈고, 6번째 packet(2393) 은 해당 데이터를 정상적으로 받았음을 의미한다.</p><p>7번째(2404)부터, 갑작스럽게 server 에서 client 측으로 <code>FIN</code> 을 보내면서, connection 을 닫는다. client 입장에서는 request 를 제대로 보냈으나 갑작스럽게 <code>FIN</code> 으로 connection 을 닫으라는 메세지를 받았으므로, 예상치 못한 상황이라 예외를 던진다. 에러 메세지 <code>Connection prematurely closed BEFORE response</code> 가 어떤 의미인지 이해가 될 것이다.</p><p>이번에는 반대로 <code>channelActive</code> 쪽 close 만 사용해보자. 이번에는 기존과 달리 <code>Connection reset by peer</code> 에러가 발생한다. 이 또한 packet 을 살펴보자.</p><p><img loading=lazy src=./image3.png alt=image.png></p><p>1~4 번째 packet(2239, 2240, 2242, 2244) 은 기존과 동일하게, 3-way handshake 이후 sliding window 를 위한 packet 을 주고받았다. 5번째 packet(2251) 에서,TCP 연결을 맺자마자, server 측에서 <code>FIN</code> 을 보내 connection 종료를 보내는 것을 볼 수 있다. 그러나 7번째 packet(2257) 에서 client 는 이미 종료된 connection 에 대해 요청을 보내버렸고, server 측에서는 “난 이미 종료했는데?” 라며 <code>RST</code> 플래그를 응답한것이다.</p><blockquote><p>6번째 packet 에서, server 의 <code>FIN</code> 에 client 가 <code>ACK</code> 으로 응답했음에도 요청을 보낸 이유는 비동기적인 측면이 원인으로 추측하고 있다. reactor netty 에서는 요청을 한창 보내려고 준비중인 와중에, netty framework 가 우선 <code>ACK</code> 을 먼저 응답하고, 요청을 중단하려고 보니까 이미 데이터는 요청된 것으로 보인다.</p></blockquote><p>만약 본인이 webClient 를 사용하다가, 해당 에러가 발생하는데 정확히 무슨 원인인지 파악하기 어렵다면 위 내용을 참고하여 다음의 공식문서를 참고하는 것도 도움이 될 것 같다.</p><p><a href=https://projectreactor.io/docs/netty/release/reference/faq.html#faq.connection-closed>https://projectreactor.io/docs/netty/release/reference/faq.html#faq.connection-closed</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.cjlee.io/tags/spring/>Spring</a></li><li><a href=https://blog.cjlee.io/tags/webclient/>Webclient</a></li><li><a href=https://blog.cjlee.io/tags/timeout/>Timeout</a></li></ul><nav class=paginav><a class=next href=https://blog.cjlee.io/post/graceful-kafka-receiver/><span class=title>Next »</span><br><span>reactor-kafka 는 조심하자</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on x" href="https://x.com/intent/tweet/?text=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f&amp;hashtags=spring%2cwebclient%2ctimeout"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f&amp;title=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout&amp;summary=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout&amp;source=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f&title=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on whatsapp" href="https://api.whatsapp.com/send?text=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout%20-%20https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on telegram" href="https://telegram.me/share/url?text=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout&amp;url=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 헷갈리는 WebClient Timeout on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ed%97%b7%ea%b0%88%eb%a6%ac%eb%8a%94%20WebClient%20Timeout&u=https%3a%2f%2fblog.cjlee.io%2fpost%2fwebclient-timeout%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://utteranc.es/client.js repo=cjlee38/blog issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.cjlee.io/>cjlee38</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>